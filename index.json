[{"content":"日拱一卒\n宁静致远\n","permalink":"https://wudanyang6.github.io/about/","summary":"日拱一卒\n宁静致远","title":"关于我"},{"content":"正在追剧，《犬夜叉》\n","permalink":"https://wudanyang6.github.io/post/balabala/","summary":"正在追剧，《犬夜叉》","title":"犬夜叉"},{"content":"1 什么是动态库 与静态库相反，动态库在链接时不会被编译进可执行文件中。\n其在执行阶段加载到内存，并且多个程序使用同一个动态库时，只需要在内存中存在一份拷贝即可。\n因为是在运行时进行加载，速度上比静态库要慢一些。\n1.1 如何制作动态库 来个小函数\nint add(int a, int b) { return a + b; } # 1. 生成 .o 文件 gcc -c add.c -o add.o -fPIC # 2. 制作 .so 文件, 注意，这里 lib 前缀是必须带的 gcc -shared -o libadd.so add.o # 3. 编译成可执行程序时 指定一下要使用的 .so 文件，-l 后面是 add 代表 libadd.so 这个文件 gcc add_test.c -o add_test -l add -L ./ # 4. 将 libadd.so 放到动态库目录下 sudo cp libadd.so /usr/local/lib/ # 5. 重新加载动态库文件 sudo ldconfig -v # 6. 执行 ./add_test 执行成功，显示执行结果 ","permalink":"https://wudanyang6.github.io/post/c/%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93/","summary":"1 什么是动态库 与静态库相反，动态库在链接时不会被编译进可执行文件中。\n其在执行阶段加载到内存，并且多个程序使用同一个动态库时，只需要在内存中存在一份拷贝即可。\n因为是在运行时进行加载，速度上比静态库要慢一些。\n1.1 如何制作动态库 来个小函数\nint add(int a, int b) { return a + b; } # 1. 生成 .o 文件 gcc -c add.c -o add.o -fPIC # 2. 制作 .so 文件, 注意，这里 lib 前缀是必须带的 gcc -shared -o libadd.so add.o # 3. 编译成可执行程序时 指定一下要使用的 .so 文件，-l 后面是 add 代表 libadd.so 这个文件 gcc add_test.c -o add_test -l add -L ./ # 4. 将 libadd.so 放到动态库目录下 sudo cp libadd.so /usr/local/lib/ # 5.","title":"制作动态库"},{"content":"这里所说的静态库与动态库是什么呢？\n一般来说是指可以复用的代码。之前使用 PHP 或者 Go 的时候，就没有静态库或者动态库的概念。\n在 PHP 中，代码复用一般会写到一个单独的文件中，在使用的时候 include 进来直接调用即可，PHP 的解释程序会加载所有文件解析。\nGo 语言虽然也可以导出 c 的静态库与动态库，但是一般我们会直接将依赖的包 import 进来后 go get 一下，下载到本地随着 go build 生成一个可执行的二进制文件。\nc 语言的静态库是什么呢？\n什么是静态库 静态库是在编译链接阶段会随着 main 函数一起编译进二进制包的一种库。\n预处理 \u0026gt; 编译 \u0026gt; 汇编 \u0026gt; 【链接】 👆 如何制作静态库 比如，我写了个函数，希望以后能复用：\n// add.c\nint add(int a, int b) { return a + b; } 执行命令\n# 先生成 .o 文件 gcc -c add.c -o add.o # 将 .o 文件打包成 .a 文件 ar rcs add.a add.o add.a 这个文件就是一个静态库了\n使用静态库 如果要使用的话，可以先定义一个头文件：\n// add.h\nint add(int, int); // add_test.c\n#include \u0026#34;add.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; int main() { printf(\u0026#34;add result: %d\\n\u0026#34;, add(5, 3)); } 编译\ngcc add_test.c lib/add.a -I header -o add_test 执行一下\nubuntu@foo:~/workspace/c_study$ ./add_test add result: 8 文件目录 参考 C++静态库与动态库\n06数据段的合并-爱代码爱编程\n静态链接时被依赖的库放到后面的原因？\n","permalink":"https://wudanyang6.github.io/post/c/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93/","summary":"这里所说的静态库与动态库是什么呢？\n一般来说是指可以复用的代码。之前使用 PHP 或者 Go 的时候，就没有静态库或者动态库的概念。\n在 PHP 中，代码复用一般会写到一个单独的文件中，在使用的时候 include 进来直接调用即可，PHP 的解释程序会加载所有文件解析。\nGo 语言虽然也可以导出 c 的静态库与动态库，但是一般我们会直接将依赖的包 import 进来后 go get 一下，下载到本地随着 go build 生成一个可执行的二进制文件。\nc 语言的静态库是什么呢？\n什么是静态库 静态库是在编译链接阶段会随着 main 函数一起编译进二进制包的一种库。\n预处理 \u0026gt; 编译 \u0026gt; 汇编 \u0026gt; 【链接】 👆 如何制作静态库 比如，我写了个函数，希望以后能复用：\n// add.c\nint add(int a, int b) { return a + b; } 执行命令\n# 先生成 .o 文件 gcc -c add.c -o add.o # 将 .o 文件打包成 .a 文件 ar rcs add.","title":"制作静态库"},{"content":"什么是 make ？ 什么是 make: Introduction\nThe make utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them. make 指令自动化地决定一个大型程序的哪部分需要重新编译，并且发出指令重新编译。\n简单理解就是，gcc 的编译指令太繁琐并且手写不方便，需要几个工具来管理。这就是 make 工具干的事儿\n什么是 makefile ？ Introduction\nYou need a file called a makefile to tell make what to do. Most often, the makefile tells make how to compile and link a program. 需要使用 makefile 这个文件，来告诉 make 需要做什么。常见的用法是描述如何编译以及链接程序\nmakefile 就是编译链接的描述文件。\nmakefile 基本使用 make makefile 一个规则 为了编译出 target， 会找 prerequisites 文件，如果找不到会在 makefile 中寻找将 prerequisites 作为目标的配置，先生成 prerequisites 文件\ntarget … : prerequisites … recipe … … 目标（target）：需要生成的文件 依赖条件（prerequisites）：生成目标所需要的文件 配方，指令（recipe）：真正执行的命令 clean: （没有依赖）\n-rm -rf $(obj) a.out `\u0026quot;-\u0026quot;` 作用是删除不存在的文件时，不报错，继续执行 ALL: (跟最终目标，否则将第一个目标作为最终目标)\n两个函数 wildcard 通配符，能够匹配所有的 .c 结尾的文件，作为列表放到 src 变量中 src = $(wildcard ./*.c) patsubst 文本替换 ，将所有 %.c 的内容替换成 %.o obj = $(patsubst %.c, %.o, $(src)) 三个自动变量 $@: 表示规则中的目标（target） $^: 表示规则中的所有依赖条件 $\u0026lt;: 表示规则中的第一个依赖条件，并且在模式规则（%.o:%.c）中，代表每次使用一个依赖生成一个目标 伪目标 .PHONY: clean ALL 伪目标的作用是为了防止你的文件夹中有相应的叫 clean 或者 ALL 文件的时候，make 将其当作目标文件。\n小练习 [!note] 小练习\n编写一个 makefile 可以将其所在目录下的所有独立 .c 文件编译生成同名可执行文件\nsrc=$(wildcard *.c) targets=$(patsubst %.c, %, $(src)) ALL:$(targets) %:%.c cc $\u0026lt; -o ./bin/$@ clean: -rm -rf ./bin/* .PHONY: clean ALL ","permalink":"https://wudanyang6.github.io/post/c/make-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"什么是 make ？ 什么是 make: Introduction\nThe make utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them. make 指令自动化地决定一个大型程序的哪部分需要重新编译，并且发出指令重新编译。\n简单理解就是，gcc 的编译指令太繁琐并且手写不方便，需要几个工具来管理。这就是 make 工具干的事儿\n什么是 makefile ？ Introduction\nYou need a file called a makefile to tell make what to do. Most often, the makefile tells make how to compile and link a program. 需要使用 makefile 这个文件，来告诉 make 需要做什么。常见的用法是描述如何编译以及链接程序\nmakefile 就是编译链接的描述文件。","title":"make 基本使用"},{"content":"媳妇儿公司是做政府项目外包的，平时接待的大多是五十往上的老年人。\n前天媳妇儿跟我说，她接到了一个简历，简历上的人是之前的工作是个程序员，因为上个项目结束，被辞退了，最近大环境不好在家呆了很长时间没找到工作，投了他们公司。\n说起来程序员看似挣得多，但是危机还是很严重的，不像有一些其他工作越老越吃香。而且程序员这行更新换代快，说不定某一天突然出现什么变革，现在使用的技术都不能使用了。就比如之前一直很火的 PHP ，突然之间热度降低了特别多，工作机会也变少了很多。\n所以想想以后怎么走很有必要。\n以前一直想去一个做架构的地方，希望能一直做技术，这样到哪都是通用的，可以一直干，但是像我这样不是特别好的学校，而且没有特别突出的表现，跟那些好学校的人才还是有一些差距。做业务吧，某天换了家公司，就会发现，对业务熟悉的优势，随着换公司就会变为接近于零。\n效仿前人，把以后的路规划成两步，短期和长期。\n短期内\n公司的业务更熟悉一些，毕竟是生活之本 学习 go 语言，随时做好语言的切换准备，摸透公司里面一个叫 qta 的微服务 长期来看\n把身体调养好，毕竟是革命的本钱 按时睡觉，感觉比较困难，每天回家的时间不固定 不吃辛辣、油腻的食品。这个比较好控制，辛辣基本不吃了，油腻的也刻意在控制 不喝碳酸饮料。 每周至少做一个小时的有氧运动 把学校里没学好的基础部分补足 Linux 系统编程，正在学习 Linux 网络编程 算法也需要常常练习，不能变得生疏，能锻炼自己的思维能力 学习 rust 语言，觉得 rust 语言会是以后的主要语言之一，学习过程中，确实能感觉到在使用 PHP 编程时觉得会出现坑的点（不判断返回值，返回值是 null 等等），以及多线程等方式不方便的地方，rust 都有比较好的解决方案。只不过这个语言对安全管控的很严格，越到后面学习起来越难，甚至讲到 Box 的时候，都不知道应该往里面传什么参数了，怪不得有人说，rust 最大的困难是通过编译。 ","permalink":"https://wudanyang6.github.io/post/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E7%9A%84%E6%80%9D%E8%80%83/","summary":"媳妇儿公司是做政府项目外包的，平时接待的大多是五十往上的老年人。\n前天媳妇儿跟我说，她接到了一个简历，简历上的人是之前的工作是个程序员，因为上个项目结束，被辞退了，最近大环境不好在家呆了很长时间没找到工作，投了他们公司。\n说起来程序员看似挣得多，但是危机还是很严重的，不像有一些其他工作越老越吃香。而且程序员这行更新换代快，说不定某一天突然出现什么变革，现在使用的技术都不能使用了。就比如之前一直很火的 PHP ，突然之间热度降低了特别多，工作机会也变少了很多。\n所以想想以后怎么走很有必要。\n以前一直想去一个做架构的地方，希望能一直做技术，这样到哪都是通用的，可以一直干，但是像我这样不是特别好的学校，而且没有特别突出的表现，跟那些好学校的人才还是有一些差距。做业务吧，某天换了家公司，就会发现，对业务熟悉的优势，随着换公司就会变为接近于零。\n效仿前人，把以后的路规划成两步，短期和长期。\n短期内\n公司的业务更熟悉一些，毕竟是生活之本 学习 go 语言，随时做好语言的切换准备，摸透公司里面一个叫 qta 的微服务 长期来看\n把身体调养好，毕竟是革命的本钱 按时睡觉，感觉比较困难，每天回家的时间不固定 不吃辛辣、油腻的食品。这个比较好控制，辛辣基本不吃了，油腻的也刻意在控制 不喝碳酸饮料。 每周至少做一个小时的有氧运动 把学校里没学好的基础部分补足 Linux 系统编程，正在学习 Linux 网络编程 算法也需要常常练习，不能变得生疏，能锻炼自己的思维能力 学习 rust 语言，觉得 rust 语言会是以后的主要语言之一，学习过程中，确实能感觉到在使用 PHP 编程时觉得会出现坑的点（不判断返回值，返回值是 null 等等），以及多线程等方式不方便的地方，rust 都有比较好的解决方案。只不过这个语言对安全管控的很严格，越到后面学习起来越难，甚至讲到 Box 的时候，都不知道应该往里面传什么参数了，怪不得有人说，rust 最大的困难是通过编译。 ","title":"关于职业生涯的思考"},{"content":"1 什么是 gdb gdb 全称：\u0026quot;GNU symbolic debugger\u0026quot;\n是一个 gnu 项目孵化出来的调试工具\n最常用来调试 c、c++ 程序\n2 基本使用 2.1 生成调试信息 在使用 gdb 之前，可执行程序需要生成调试信息\ng++ test.c -g -o test -g 会在可执行文件中生成一个用于调试的符号表\n2.2 启动 gdb 直接后面参数是可执行文件就可以启动调试\ngdb test 如果要debug一个正在运行的程序，可以使用 -p 参数指定进程id\ngdb -p $PID 效果如下图所示 2.3 调试程序 几个基本指令：\nfile：从文件导入调试信息符号表 start：从头开始并在首行进入断点执行 r(un)：执行 n(ext)：单步跳过 s(tep)：单步进入 fin(ish)：单步跳出 c(ontinue)：继续，执行到下一个断点 b(reak)：行号，在第几行打断点；function_name，在函数开始断点 p(rint)：打印变量值 ptype：打印变量类型 quit：退出当前调试 display：跟踪变量（相当于其他工具的监视 watch） bt：栈信息 frame：激活栈，默认显示当前栈帧 一般的工作流是：\ngdb 【带有调试信息的可执行程序】 【列出当前执行位置后面的代码】\n(gdb) l 795\t/* NGX_TIMER_INFINITE == INFTIM */ 796 797\tngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-\u0026gt;log, 0, 798\t\u0026#34;epoll timer: %M\u0026#34;, timer); 799 800\tevents = epoll_wait(ep, event_list, (int) nevents, timer); 801 802\terr = (events == -1) ? ngx_errno : 0; 803 804\tif (flags \u0026amp; NGX_UPDATE_TIME || ngx_event_timer_alarm) { 【在第 800 行设置断点】\n(gdb) b 800 (gdb) c Continuing. 【这里程序会运行到800行断点处】 Breakpoint 1, ngx_epoll_process_events (cycle=0xaaaab5a70700, timer=60000, flags=1) at src/event/modules/ngx_epoll_module.c:800 800\tevents = epoll_wait(ep, event_list, (int) nevents, timer); 【看一下刚才设置的断点信息】\n(gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000aaaab0f35414 in ngx_epoll_process_events at src/event/modules/ngx_epoll_module.c:800 breakpoint already hit 2 times 【看下当前在什么函数中】\n(gdb) bt #0 ngx_epoll_process_events (cycle=0xaaaab5a70700, timer=60000, flags=1) at src/event/modules/ngx_epoll_module.c:800 #1 0x0000aaaab0f29c58 in ngx_process_events_and_timers (cycle=cycle@entry=0xaaaab5a70700) at src/event/ngx_event.c:248 #2 0x0000aaaab0f3268c in ngx_worker_process_cycle (cycle=0xaaaab5a70700, data=\u0026lt;optimized out\u0026gt;) at src/os/unix/ngx_process_cycle.c:721 #3 0x0000aaaab0f30a80 in ngx_spawn_process (cycle=cycle@entry=0xaaaab5a70700, proc=0xaaaab0f32568 \u0026lt;ngx_worker_process_cycle\u0026gt;, data=0x0, name=0xaaaab0f8d7d8 \u0026#34;worker process\u0026#34;, respawn=respawn@entry=0) at src/os/unix/ngx_process.c:199 #4 0x0000aaaab0f330a0 in ngx_reap_children (cycle=0xaaaab5a70700) at src/os/unix/ngx_process_cycle.c:598 #5 ngx_master_process_cycle (cycle=0xaaaab5a70700) at src/os/unix/ngx_process_cycle.c:174 #6 0x0000aaaab0f08574 in main (argc=\u0026lt;optimized out\u0026gt;, argv=\u0026lt;optimized out\u0026gt;) at src/core/nginx.c:383 【监视变量：events 与 event_list】\n(gdb) display events 1: events = \u0026lt;optimized out\u0026gt; (gdb) display event_list 2: event_list = (struct epoll_event *) 0xaaaab5a7d6f0 (gdb) n 802\terr = (events == -1) ? ngx_errno : 0; 1: events = 2 2: event_list = (struct epoll_event *) 0xaaaab5a7d6f0 【取消监视变量】\n(gdb) undisplay 1 (gdb) n 802\terr = (events == -1) ? ngx_errno : 0; 2: event_list = (struct epoll_event *) 0xaaaab5a7d6f0 (gdb) undisplay 2 (gdb) n 804\tif (flags \u0026amp; NGX_UPDATE_TIME || ngx_event_timer_alarm) { 【查看变量值】\n(gdb) p flags $2 = 1 (gdb) p ngx_event_timer_alarm $3 = 0 参考 3.9 Options for Debugging Your Program or GCC GDB: The GNU Project Debugger ","permalink":"https://wudanyang6.github.io/post/c/gdb-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"1 什么是 gdb gdb 全称：\u0026quot;GNU symbolic debugger\u0026quot;\n是一个 gnu 项目孵化出来的调试工具\n最常用来调试 c、c++ 程序\n2 基本使用 2.1 生成调试信息 在使用 gdb 之前，可执行程序需要生成调试信息\ng++ test.c -g -o test -g 会在可执行文件中生成一个用于调试的符号表\n2.2 启动 gdb 直接后面参数是可执行文件就可以启动调试\ngdb test 如果要debug一个正在运行的程序，可以使用 -p 参数指定进程id\ngdb -p $PID 效果如下图所示 2.3 调试程序 几个基本指令：\nfile：从文件导入调试信息符号表 start：从头开始并在首行进入断点执行 r(un)：执行 n(ext)：单步跳过 s(tep)：单步进入 fin(ish)：单步跳出 c(ontinue)：继续，执行到下一个断点 b(reak)：行号，在第几行打断点；function_name，在函数开始断点 p(rint)：打印变量值 ptype：打印变量类型 quit：退出当前调试 display：跟踪变量（相当于其他工具的监视 watch） bt：栈信息 frame：激活栈，默认显示当前栈帧 一般的工作流是：\ngdb 【带有调试信息的可执行程序】 【列出当前执行位置后面的代码】\n(gdb) l 795\t/* NGX_TIMER_INFINITE == INFTIM */ 796 797\tngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-\u0026gt;log, 0, 798\t\u0026#34;epoll timer: %M\u0026#34;, timer); 799 800\tevents = epoll_wait(ep, event_list, (int) nevents, timer); 801 802\terr = (events == -1) ?","title":"gdb 基本使用"},{"content":"一段普通的 c++ 代码是如何变成可执行程序的 (使用 g++ 命令编译 c++ 代码)\nusing namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 会经过4个步骤\n预处理 编译 汇编 链接 预处理 作用：宏替换（展开文本，include 文本替换），删除空格等文本处理\n相关语句 -E 仅生成 .i 预处理后的文件\n编译 -S 仅生成 .s 编译后 .s 后缀文件\n将c代码解析后生成汇编语句\n下面代码是一部分汇编语句\nubuntu@foo:~/test$ cat test.s .arch armv8-a .file\t\u0026#34;test.c\u0026#34; .text .section\t.rodata .align\t3 .type\t_ZStL19piecewise_construct, %object .size\t_ZStL19piecewise_construct, 1 _ZStL19piecewise_construct: .zero\t1 .local\t_ZStL8__ioinit .comm\t_ZStL8__ioinit,1,8 .align\t3 .LC0: .string\t\u0026#34;hello, world\u0026#34; .text .align\t2 .global\tmain .type\tmain, %function main: .LFB1521: .cfi_startproc stp\tx29, x30, [sp, -16]! .cfi_def_cfa_offset 16 .cfi_offset 29, -16 .cfi_offset 30, -8 mov\tx29, sp adrp\tx0, .LC0 add\tx1, x0, :lo12:.LC0 adrp\tx0, :got:_ZSt4cout ldr\tx0, [x0, #:got_lo12:_ZSt4cout] bl\t_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc mov\tx2, x0 adrp\tx0, :got:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ 汇编 将汇编语句转换成 机器码 (二进制)\n-c 仅生成汇编后的 .o 后缀文件\n链接 将静态链接库与动态链接库链接到程序中\n生成的可执行文件中会多很多信息\n总结 经过4个步骤处理之后，最终就可以执行了\nOK，精通 hello world\n","permalink":"https://wudanyang6.github.io/post/c/gcc%E7%BC%96%E8%AF%91%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/","summary":"一段普通的 c++ 代码是如何变成可执行程序的 (使用 g++ 命令编译 c++ 代码)\nusing namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hello, world\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 会经过4个步骤\n预处理 编译 汇编 链接 预处理 作用：宏替换（展开文本，include 文本替换），删除空格等文本处理\n相关语句 -E 仅生成 .i 预处理后的文件\n编译 -S 仅生成 .s 编译后 .s 后缀文件\n将c代码解析后生成汇编语句\n下面代码是一部分汇编语句\nubuntu@foo:~/test$ cat test.s .arch armv8-a .file\t\u0026#34;test.c\u0026#34; .text .section\t.rodata .align\t3 .type\t_ZStL19piecewise_construct, %object .size\t_ZStL19piecewise_construct, 1 _ZStL19piecewise_construct: .zero\t1 .local\t_ZStL8__ioinit .comm\t_ZStL8__ioinit,1,8 .","title":"gcc编译的几个过程"},{"content":"1 通过源码安装 nginx 1.1 下载源码 git clone https://github.com/nginx/nginx 1.2 编译并安装 nginx 修改 nginx 源码中的配置文件：auto/cc/conf\n将第 12 行修改一下\nngx_compile_opt=\u0026quot;-c\u0026quot; 改成： ngx_compile_opt=\u0026quot;-c -g\u0026quot;\n-g 选项会让编译器产生调试信息\n执行配置并安装：\ncd nginx auto/configure 默认被安装在 /usr/local/nginx ，可以通过 --prefix 选项修改\n继续执行 make \u0026amp;\u0026amp; make install\n到这里，nginx 就安装完毕了\n1.3 启动 nginx /usr/local/nginx 默认监听本机 80 端口\n完成设置后会出现下面的图片：\nWelcome to nginx!\n2 配置 vscode 2.1 打开项目 使用 vscode 打开下载下来的源码文件夹\n2.2 安装调试插件 名称: CodeLLDB ID: vadimcn.vscode-lldb 说明: A native debugger powered by LLDB. Debug C++, Rust and other compiled languages. 版本: 1.7.0 发布者: Vadim Chugunov VS Marketplace 链接: https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb 在插件库搜索此插件并安装\n2.3 调试配置 如图，打开调试文件：\n下面是调试的配置文件，pid 可以设置成 master 或者 worker 的 PID\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ // 监听工作进程 { \u0026#34;name\u0026#34;: \u0026#34;(lldb) Attach\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;attach\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;95318\u0026#34;, // 填写 Worker 进程 PID， 需要修改 } ] } 我这里设置成了 worker 进程的 PID\n到这里，vscode 中的配置就完成了\n3 断点调试 在 ngx_http_parse_request_line 设置断点\n再次通过浏览器请求 localhost ，会发现 vscode 上方出现了调试用的几个按钮以及停在了断点处\n4 参考 Mac上用Visual Studio Code调试Nginx 这个教程在 M1 芯片的 mac 上面无法使用 GCC 参数详解 ","permalink":"https://wudanyang6.github.io/post/nginx/vscode-nginx-debug/","summary":"1 通过源码安装 nginx 1.1 下载源码 git clone https://github.com/nginx/nginx 1.2 编译并安装 nginx 修改 nginx 源码中的配置文件：auto/cc/conf\n将第 12 行修改一下\nngx_compile_opt=\u0026quot;-c\u0026quot; 改成： ngx_compile_opt=\u0026quot;-c -g\u0026quot;\n-g 选项会让编译器产生调试信息\n执行配置并安装：\ncd nginx auto/configure 默认被安装在 /usr/local/nginx ，可以通过 --prefix 选项修改\n继续执行 make \u0026amp;\u0026amp; make install\n到这里，nginx 就安装完毕了\n1.3 启动 nginx /usr/local/nginx 默认监听本机 80 端口\n完成设置后会出现下面的图片：\nWelcome to nginx!\n2 配置 vscode 2.1 打开项目 使用 vscode 打开下载下来的源码文件夹\n2.2 安装调试插件 名称: CodeLLDB ID: vadimcn.vscode-lldb 说明: A native debugger powered by LLDB.","title":"vscode debug nginx 源码"},{"content":"b 站 up 主，软件工艺师 杨旭\n全篇基本没废话，干货一路通到底\n","permalink":"https://wudanyang6.github.io/post/rust/rust-%E6%95%99%E7%A8%8B%E6%8E%A8%E8%8D%90/","summary":"b 站 up 主，软件工艺师 杨旭\n全篇基本没废话，干货一路通到底","title":"rust 教程推荐"},{"content":"最近游戏一直在玩原神，一个开放的大世界。主线剧情刚刚做完，确实是我想象中的角色扮演（RPG）游戏。\n记得高中在塞班手机上玩的一款RPG游戏，一个周末都在刷怪。后来重新练了个号，结果跟大师傅打架的时候，他的70级宠物不知道为什么变成我的了。我就带着一个70级将近满级的宠物一路过关斩将玩通关了。\n原神里面我自己感觉可玩的点有几个：\n角色都很二次元，都是按照动漫里面的角色画出来的，二次元的估计会很喜欢。\n剧情比较代入，某些剧情需要努力打怪，不过主线剧情并不是很难。\n大世界地图非常大，如果不是有传送节点估计跑图都得跑断腿。\n大世界里面有很多宝箱，有些宝箱需要解密之后才能获得，不过这些宝箱都是一次性的，我在蒙德、璃月、稻妻的探索度最高才到 50% ，所以也可见大世界有多大东西有多丰富。\n支线剧情也很丰富多彩，比如我就特别喜欢璃月里面的一个支线剧情《神女劈观》，并且剧情最后有一首歌，大家可以先听一下。不过没有了解剧情之前听这首歌触动应该不是很大，还是具体体验一下剧情再说。\n最后一点，原神不花钱氪金也可以玩的很舒服，每天做做每日任务，开开宝箱，欣赏欣赏美景，然后读一读角色的背景故事。\n对了，游戏社区里的前辈忠告，当深渊不存在，能打到哪里就打到哪里。\n","permalink":"https://wudanyang6.github.io/post/games/%E5%8E%9F%E7%A5%9E%E6%8C%BA%E5%A5%BD%E7%8E%A9/","summary":"最近游戏一直在玩原神，一个开放的大世界。主线剧情刚刚做完，确实是我想象中的角色扮演（RPG）游戏。\n记得高中在塞班手机上玩的一款RPG游戏，一个周末都在刷怪。后来重新练了个号，结果跟大师傅打架的时候，他的70级宠物不知道为什么变成我的了。我就带着一个70级将近满级的宠物一路过关斩将玩通关了。\n原神里面我自己感觉可玩的点有几个：\n角色都很二次元，都是按照动漫里面的角色画出来的，二次元的估计会很喜欢。\n剧情比较代入，某些剧情需要努力打怪，不过主线剧情并不是很难。\n大世界地图非常大，如果不是有传送节点估计跑图都得跑断腿。\n大世界里面有很多宝箱，有些宝箱需要解密之后才能获得，不过这些宝箱都是一次性的，我在蒙德、璃月、稻妻的探索度最高才到 50% ，所以也可见大世界有多大东西有多丰富。\n支线剧情也很丰富多彩，比如我就特别喜欢璃月里面的一个支线剧情《神女劈观》，并且剧情最后有一首歌，大家可以先听一下。不过没有了解剧情之前听这首歌触动应该不是很大，还是具体体验一下剧情再说。\n最后一点，原神不花钱氪金也可以玩的很舒服，每天做做每日任务，开开宝箱，欣赏欣赏美景，然后读一读角色的背景故事。\n对了，游戏社区里的前辈忠告，当深渊不存在，能打到哪里就打到哪里。","title":"原神挺好玩"},{"content":"最近看到很多计算机企业在制裁俄罗斯，制裁手段包括软件禁止俄罗斯使用，云服务停止等等。\n网络上确实也充斥着很多公众号的推文，说俄罗斯的现在很可能就是以后的中国。不过这个以后正在到来，而且也发生了，Figma 禁止大疆使用服务。\n未雨绸缪，回想一下自己常用的一些软件，以及替代方案。\nphpstorm 本地软件 即使不更新也可以继续使用旧版本，但是不能保证后续不会被远程限制使用 obsidian 本地软件 软件是个本地软件，开发者看着也是中国人，如果被封，还能继续使用现有版本 苹果系统 如果真有一天苹果系统被停止服务，我们应该也可以继续使用现有版本，只不过不能使用 icloud。是在不行就迁移到深度系统 替代品：深度操作系统 icloud 替代品：坚果云，应该是我知道的国内唯一比较好用的替代方案了 chrome firefox 360 浏览器等一系列国产套壳浏览器 iTerm 系统默认终端也能用，只不过没有这个这么方便 最担心的还是苹果电脑和系统，万一哪天漂亮国发疯，全封了，那就是不死不休了。\n","permalink":"https://wudanyang6.github.io/post/others/software-choose/","summary":"最近看到很多计算机企业在制裁俄罗斯，制裁手段包括软件禁止俄罗斯使用，云服务停止等等。\n网络上确实也充斥着很多公众号的推文，说俄罗斯的现在很可能就是以后的中国。不过这个以后正在到来，而且也发生了，Figma 禁止大疆使用服务。\n未雨绸缪，回想一下自己常用的一些软件，以及替代方案。\nphpstorm 本地软件 即使不更新也可以继续使用旧版本，但是不能保证后续不会被远程限制使用 obsidian 本地软件 软件是个本地软件，开发者看着也是中国人，如果被封，还能继续使用现有版本 苹果系统 如果真有一天苹果系统被停止服务，我们应该也可以继续使用现有版本，只不过不能使用 icloud。是在不行就迁移到深度系统 替代品：深度操作系统 icloud 替代品：坚果云，应该是我知道的国内唯一比较好用的替代方案了 chrome firefox 360 浏览器等一系列国产套壳浏览器 iTerm 系统默认终端也能用，只不过没有这个这么方便 最担心的还是苹果电脑和系统，万一哪天漂亮国发疯，全封了，那就是不死不休了。","title":"软件选择"},{"content":"使用 Hugo 创建站点 首先打开 Hugo 官网 Quick start\nhugo 的安装就不说了，如果这一步觉得很困难，就可以放弃了。\n新建站点new hugo new site quickstart cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml 上述做完之后，可以先别急着玩主题，咱们可以后面慢慢探索\n添加内容 hugo new posts/my-first-post.md 这时，我们可以打开 posts/my-first-post.md ，在里面使用 markdown 语法写一写文字。\n比如我这里 使用 hugo server 命令可以在本地预览站点效果，如下所示：\n发布网站 我们使用 hugo 命令生成静态文件，将静态文件上传到托管服务器\n常见的托管服务器可以使用阿里云、百度云、腾讯云等多种云平台。\n不过我们这里介绍的是一个免费的服务 GitHub pages\n创建 Github pages 我这里将文章、配置等元数据和网站数据分了两个仓库\n元数据仓库设置成了私有，因为里面有可能有一些敏感信息 网站仓库设置为公开，开启 GitHub pages 服务 当然，你也可以设置成公开并且都使用一个仓库。\n网站仓库打开 Settings 选择 Pages 选项，选择数据源分支\n示例 如下图所示，我这里分支设置成了 gh-pages 分支的根目录，并且使用了一个自定义域名，而且开启了强制 https 访问。自定义域名和 https 第一次使用完全可以不理会，咱们接着往下看。\n有了 GitHub pages 之后，咱们可以在生成的 public 文件夹下创建一个 git 仓库，或者直接在上面的路径 /root 配置成 public 目录。将生成的站点数据 push 到 github 即可。\n但是这样一通操作还是很复杂，而且我并不想让在私有仓库里面开启 pages 服务（要收费）\ngithub 提供了另外一项服务：workflows。\n这里 hugo 也提供了一个 workflow hugo-setup，可以通过 github 仓库数据生成静态文件，并自动部署。\n发布的仓库可以修改成刚才创建的 网站仓库\nworkflow 的具体配置就不细说了，可以参考 github 的教程。\n上面一套下来，git push 之后就会跟着一次自动部署，非常方便\nmarkdown 编辑器 Obsidian 市面上有很多 markdown 编辑器，并且各有优劣，这里介绍一个比较中规中矩，基本能满足要求的编辑器：Obsidian。\nObsidian 最近更新之后可以支持所见即所得的编辑，并且体验还不错。不过如果你对编辑器要求比较高，也可以使用 typora 。\n这款编辑器下限较低，开箱即用，用完即走。但是上限很高，主打双链知识图谱功能，并且有非常丰富的插件，活跃的社区，无限的可能。\n咱们就主要用这款编辑器，后面介绍图床的时候，会介绍到 Obsidian 的一个好处。\n图床 到这里，hugo 创建站点了，网站也能发布了，基本的文字编辑也解决了。\n还有一个比较大的问题，图片怎么办？\n主流的方案是使用第三方图床，上传到第三方图床之后，将图片地址放到 markdown 中。\nhugo 给出了另外一个方案，将图片放到 static （可配置）目录下，hugo 会将 static 目录下的内容放到站点根目录。\n也就是说，我在 static 目录下的 a.png 可以通过 /a.png 的方式访问到。\n这样的话，图片的问题也解决了。\n但是不完美的是， /a.png 在编辑器无法识别，无法显示这张图片。\n我这里给出一个折中的方案，在 obsidian 中配置一下选项： 配置好之后，就可以在文件中去掉 / 前缀，并且obsidian也能识别图片并显示。\n然后在 static/js 目录下创建一个 img_trick.js 文件，放入以下内容\n$(\u0026#34;.post .post-content img\u0026#34;).each(function () { $(this).attr(\u0026#39;src\u0026#39;, \u0026#34;/img/\u0026#34; + $(this).attr(\u0026#39;src\u0026#39;)) }) 这段代码会将 content 中的所有图片地址前面拼上 /img/ 路径，页面就回去找站点根目录下面的 img/图片 ，最终用户就可以看到图片。\n总结 自此，一键发布全部结束。\n如果有兴趣的话，可以继续探索 hugo 的更多主题，我用的是 even 主题。\n也可以继续探索 obsidian 的更多插件（比如 obsidian-git 插件可以定时 push 修改）。\n","permalink":"https://wudanyang6.github.io/post/hugo-%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83/","summary":"使用 Hugo 创建站点 首先打开 Hugo 官网 Quick start\nhugo 的安装就不说了，如果这一步觉得很困难，就可以放弃了。\n新建站点new hugo new site quickstart cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml 上述做完之后，可以先别急着玩主题，咱们可以后面慢慢探索\n添加内容 hugo new posts/my-first-post.md 这时，我们可以打开 posts/my-first-post.md ，在里面使用 markdown 语法写一写文字。\n比如我这里 使用 hugo server 命令可以在本地预览站点效果，如下所示：\n发布网站 我们使用 hugo 命令生成静态文件，将静态文件上传到托管服务器\n常见的托管服务器可以使用阿里云、百度云、腾讯云等多种云平台。\n不过我们这里介绍的是一个免费的服务 GitHub pages\n创建 Github pages 我这里将文章、配置等元数据和网站数据分了两个仓库\n元数据仓库设置成了私有，因为里面有可能有一些敏感信息 网站仓库设置为公开，开启 GitHub pages 服务 当然，你也可以设置成公开并且都使用一个仓库。\n网站仓库打开 Settings 选择 Pages 选项，选择数据源分支\n示例 如下图所示，我这里分支设置成了 gh-pages 分支的根目录，并且使用了一个自定义域名，而且开启了强制 https 访问。自定义域名和 https 第一次使用完全可以不理会，咱们接着往下看。","title":"hugo 实现写完一键发布"},{"content":"树莓派 ubuntu 配置网络 树莓派现在可以安装很多操作系统，其中 ubuntu 也提供了树莓派版本，因为对 ubuntu 更加熟悉，所以就往 SD 卡中烧录了 ubuntu 的 20.04 lts 64位 版本。这里有可供选择的操作系统。\n简单提一嘴烧录操作系统到 SD 卡上面的方法，树莓派提供了一个傻瓜式的软件给大家使用，直接打开之后选择系统，就可以烧录了，烧录过程大概会有几分钟。\n烧录完成之后，如果你按照树莓派官网的教程进行操作，肯定都行不通，因为树莓派的官方操作系统 Raspberry Pi OS 和 Ubuntu For Raspberry 上面的网络配置方式完全不一样。\n安装了 ubuntu 的树莓派怎么配置网络？ 打开你烧录好的 SD 卡\n找到 network-config 文件\n写入如下配置：\nwifis: wlan0: dhcp4: true optional: true access-points: \u0026lt;wifi network name\u0026gt;: password: \u0026#34;\u0026lt;wifi password\u0026gt;\u0026#34; 如果是企业网络：\nwifis: wlan0: dhcp4: true optional: true access-points: \u0026lt;wifi network name\u0026gt;: auth: key-management: eap method: peap identity: \u0026#34;wudanyang\u0026#34; password: \u0026#34;\u0026#34; 配置文件的格式\n修改完之后，把 SD 卡从电脑上弹出，然后插到树莓派里。\n不过，重启之后，你可能还是无法连接到网络。可以看下这里\nNote: During the first boot, your Raspberry Pi will try to connect to this network. It will fail the first time around. Simply reboot sudo reboot and it will work.\n引用ubuntu官网的一段话，第一次会失败，直接重启，第二次就能连上了。\n开启网络之后，如何登录树莓派？ 安装好之后默认用户名和密码都是 ubuntu\nssh ubuntu@\u0026lt;raspberry ip\u0026gt;\nip 地址的获取这里列举几种方法，不详细介绍：\n自己的路由器：登录后台查看分配的 ip 局域网扫描（局域网机器不多的情况下）： 下载个局域网扫描工具，如果局域网机器不多，会看到一个制造商为树莓派的 ip 使用命令行 arp -a 挨个试一下 ubuntu 启动之后会使用 avahi 服务通过 mdns 协议在局域网注册一个域名 ubuntu.local，所以你可以这样登录 ssh ubuntu@ubuntu.local 参考 树莓派支持的操作系统\n树莓派操作系统烧录软件\n无屏幕和键盘配置树莓派WiFi和SSH\n百度百科-mdns\n","permalink":"https://wudanyang6.github.io/post/raspberry/ubuntu-network/","summary":"树莓派 ubuntu 配置网络 树莓派现在可以安装很多操作系统，其中 ubuntu 也提供了树莓派版本，因为对 ubuntu 更加熟悉，所以就往 SD 卡中烧录了 ubuntu 的 20.04 lts 64位 版本。这里有可供选择的操作系统。\n简单提一嘴烧录操作系统到 SD 卡上面的方法，树莓派提供了一个傻瓜式的软件给大家使用，直接打开之后选择系统，就可以烧录了，烧录过程大概会有几分钟。\n烧录完成之后，如果你按照树莓派官网的教程进行操作，肯定都行不通，因为树莓派的官方操作系统 Raspberry Pi OS 和 Ubuntu For Raspberry 上面的网络配置方式完全不一样。\n安装了 ubuntu 的树莓派怎么配置网络？ 打开你烧录好的 SD 卡\n找到 network-config 文件\n写入如下配置：\nwifis: wlan0: dhcp4: true optional: true access-points: \u0026lt;wifi network name\u0026gt;: password: \u0026#34;\u0026lt;wifi password\u0026gt;\u0026#34; 如果是企业网络：\nwifis: wlan0: dhcp4: true optional: true access-points: \u0026lt;wifi network name\u0026gt;: auth: key-management: eap method: peap identity: \u0026#34;wudanyang\u0026#34; password: \u0026#34;\u0026#34; 配置文件的格式","title":"树莓派 ubuntu 配置网络"},{"content":"如何调试nginx的rewrite规则？ 设置 rewrite_log on;\n并且将error_log 的报错等级改成 notice;\n官网对 rewrite_log 的解释：\nSyntax:\trewrite_log on | off; Default:\trewrite_log off; Context:\thttp, server, location, if Enables or disables logging of ngx_http_rewrite_module module directives processing results into the error_log at the notice level. 可以看到，这个指令只能在 http server location if 配置指令中使用，日志等级是 notice 写入到 error_log 配置的文件中。\n示例 url： /q?someparams\n2021/04/22 18:21:28 [notice] 18131#0: *102982 \u0026#34;^/+m/question(.*)?qid=\\d+(.*)?$\u0026#34; does not match ... ... 中间省略一些日志 2021/04/22 18:21:28 [notice] 18131#0: *102982 \u0026#34;^/+question/(\\w+.*?)$\u0026#34; does not match ... 2021/04/22 18:21:28 [notice] 18131#0: *102982 \u0026#34;^/+q\\?(.*)?tn=nsatom_qb_main(.*)?$\u0026#34; matches ... 2021/04/22 18:21:28 [notice] 18131#0: *102982 \u0026#34;^/+q\u0026#34; matches ... 2021/04/22 18:21:28 [notice] 18131#0: *102982 rewritten data: \u0026#34;/q/q/q/q/q\u0026#34; 从上面的日志中可以看出，当触发了重写规则时，会有关键字 matches 否则会有 does not match 。\n最终重写完成之后，访问的地址会有标记：rewritten data\n这里就是 /q/q/q/q/q\n参考 best way to debug nginx rewrite rules in config file?\nnginx官方文档：Module ngx_http_rewrite_module\n","permalink":"https://wudanyang6.github.io/post/nginx/how-debug-nginx-rewrite/","summary":"如何调试nginx的rewrite规则？ 设置 rewrite_log on;\n并且将error_log 的报错等级改成 notice;\n官网对 rewrite_log 的解释：\nSyntax:\trewrite_log on | off; Default:\trewrite_log off; Context:\thttp, server, location, if Enables or disables logging of ngx_http_rewrite_module module directives processing results into the error_log at the notice level. 可以看到，这个指令只能在 http server location if 配置指令中使用，日志等级是 notice 写入到 error_log 配置的文件中。\n示例 url： /q?someparams\n2021/04/22 18:21:28 [notice] 18131#0: *102982 \u0026#34;^/+m/question(.*)?qid=\\d+(.*)?$\u0026#34; does not match ... ... 中间省略一些日志 2021/04/22 18:21:28 [notice] 18131#0: *102982 \u0026#34;^/+question/(\\w+.","title":"如何调试nginx的rewrite规则?"},{"content":"nginx master 进程主流程 之前有说到 nginx 进程模型-整体架构，下面来看一下 nginx master 进程的主要工作\nnginx 的入口 main 函数在 nginx.c 文件中\n函数原型为：\nint ngx_cdecl main(int argc, char *const *argv) 在这个函数中，master 做了一系列的初始化操作\n最终在下面这个地方进入了主流程中：\n//... if (ngx_process == NGX_PROCESS_SINGLE) { ngx_single_process_cycle(cycle); } else { ngx_master_process_cycle(cycle); } //... 因为我们主要看 master-worker 这种进程模型，所以进入 ngx_master_process_cycle\n设置信号屏蔽字，防止创建子进程过程中被信号中断 // 先清空信号集 sigemptyset(\u0026amp;set); sigaddset(\u0026amp;set, SIGCHLD); sigaddset(\u0026amp;set, SIGALRM); sigaddset(\u0026amp;set, SIGIO); sigaddset(\u0026amp;set, SIGINT); sigaddset(\u0026amp;set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_REOPEN_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_NOACCEPT_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_TERMINATE_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL)); // 设置信号屏蔽字，将 set 中的信号设置为阻塞状态，防止创建worker 的过程中，被进来的信号打断 if (sigprocmask(SIG_BLOCK, \u0026amp;set, NULL) == -1) { ngx_log_error(NGX_LOG_ALERT, cycle-\u0026gt;log, ngx_errno, \u0026#34;sigprocmask() failed\u0026#34;); } // 将 set 清空 sigemptyset(\u0026amp;set); 设置信号屏蔽字，防止在创建子进程的过程中被信号处理程序中断\n关于信号屏蔽字，引用 《UNIX 环境高级编程》 中信号一节的部分内容：\n进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作或捕捉该信号, 则为该进程将此信号保持为未决状态,直到该进程对此信号解除了阻塞, 或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时),才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用 sigpending 函数(见10.13节)来判定哪些信号是设置为阻塞并处于未决状态的。\n每个进程都有一个信号屏蔽字( signal mask),它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号,该屏蔽字中都有一位与之对应。对于某种信号,若其对应位已设置,则它当前是被阻塞的。进程可以调用 sigprocmask(在10.12节中说明)来检测和更改其当前信号屏蔽字。\n当然，在下面创建完子进程之后，会使用 sigsuspend 解除信号屏蔽，并使 master 进程进入休眠\n关于 sigsuspend 函数，简单来说，它是一个 sigprocmask(SIG_SETMASK, \u0026amp;emptyset, NULL) 和 pause() 函数的结合体，不过相对于使用两个函数完成上述操作，sigsuspend 是 原子操作。\n设置 master 进程的 title static u_char master_process[] = \u0026#34;master process\u0026#34;; size = sizeof(master_process); for (i = 0; i \u0026lt; ngx_argc; i++) { size += ngx_strlen(ngx_argv[i]) + 1; } title = ngx_pnalloc(cycle-\u0026gt;pool, size); if (title == NULL) { /* fatal */ exit(2); } p = ngx_cpymem(title, master_process, sizeof(master_process) - 1); for (i = 0; i \u0026lt; ngx_argc; i++) { *p++ = \u0026#39; \u0026#39;; p = ngx_cpystrn(p, (u_char *) ngx_argv[i], size); } ngx_setproctitle(title); 将title设置成：\n固定字符：nginx: 主进程标志: master process 命令行启动的命令，如：/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx 所以进程刚开始是这样显示的：\n$ ps aux | grep nginx | grep -v grep root 183117 0.0 0.0 4324 2680 ? ts 17:07 0:00 /home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx 设置了 title 之后，变成了下面这样：\n$ ps aux | grep nginx | grep -v grep root 183117 0.0 0.0 4324 2680 ? ts 17:07 0:00 nginx: master process /home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx 根据配置启动相应数量的 worker 和 cache 管理进程 ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-\u0026gt;conf_ctx, ngx_core_module); ngx_start_worker_processes(cycle, ccf-\u0026gt;worker_processes, NGX_PROCESS_RESPAWN); ngx_start_cache_manager_processes(cycle, 0); 监听信号，并作出响应 在 ngx_init_signals 函数中，对原始信号做了变量名映射，具体映射如下：\n信号 对应进程中的标志位变量 含义 QUIT ngx_quit 优雅关闭服务 TERM 或 INT ngx_terminate 强制关闭服务 USR1 ngx_reopen 重新打开服务中的所有文件 WINCH ngx_noaccept 所有子进程不再接受处理新的连接，实际相当于对所有的子进程发送 QUIT 信号 USR2 ngx_change_binary 平滑升级到新版本的 Nginx 程序 HUP ngx_reconfigure 重新读取配置文件并使服务对新配置项生效 CHLD ngx_reap 有子进程意外结束master 会监控所有子进程，并在子进程意外退出时调用 ngx_reap_children 方法重启子进程 master 并不是时刻不停的执行循环检测这些标志位，而是通过 sigsuspend 进入休眠，等待有信号唤醒进程时，再循环检测所有信号并处理。\n参考 nginx中的ngx_cdecl\nNginx源码|Nginx信号处理\nnginx 信号处理\nLINUX C中sigprocmask()函数用法\nlinux信号的阻塞和未决\n《UNIX 环境高级编程》\n","permalink":"https://wudanyang6.github.io/post/nginx/nginx-master/","summary":"nginx master 进程主流程 之前有说到 nginx 进程模型-整体架构，下面来看一下 nginx master 进程的主要工作\nnginx 的入口 main 函数在 nginx.c 文件中\n函数原型为：\nint ngx_cdecl main(int argc, char *const *argv) 在这个函数中，master 做了一系列的初始化操作\n最终在下面这个地方进入了主流程中：\n//... if (ngx_process == NGX_PROCESS_SINGLE) { ngx_single_process_cycle(cycle); } else { ngx_master_process_cycle(cycle); } //... 因为我们主要看 master-worker 这种进程模型，所以进入 ngx_master_process_cycle\n设置信号屏蔽字，防止创建子进程过程中被信号中断 // 先清空信号集 sigemptyset(\u0026amp;set); sigaddset(\u0026amp;set, SIGCHLD); sigaddset(\u0026amp;set, SIGALRM); sigaddset(\u0026amp;set, SIGIO); sigaddset(\u0026amp;set, SIGINT); sigaddset(\u0026amp;set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_REOPEN_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_NOACCEPT_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_TERMINATE_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL)); sigaddset(\u0026amp;set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL)); // 设置信号屏蔽字，将 set 中的信号设置为阻塞状态，防止创建worker 的过程中，被进来的信号打断 if (sigprocmask(SIG_BLOCK, \u0026amp;set, NULL) == -1) { ngx_log_error(NGX_LOG_ALERT, cycle-\u0026gt;log, ngx_errno, \u0026#34;sigprocmask() failed\u0026#34;); } // 将 set 清空 sigemptyset(\u0026amp;set); 设置信号屏蔽字，防止在创建子进程的过程中被信号处理程序中断","title":"Nginx Master 进程主流程"},{"content":"什么是文件描述符 对于内核而言，所有打开的文件都通过 文件描述符（file descriptor）引用。通常也写作 fd。\n文件描述符是一个非负整数。\n当打开一个现有文件或者创建一个新文件时，内核向进程返回一个 文件描述符。\n文件描述符是跟 进程相关联的。\n按照惯例，UNIX 系统将 fd 0 对应进程的标准输入， fd 1 对应进程的标准输出， fd 2 对应进程的标准错误。\n系统调用中的文件描述符 UNIX 系统中，一切皆文件，所以一切资源都可以使用文件描述符进程引用。\n以 open 系统调用为例\n使用 man 2 open 查看系统 man 手册\nNAME open, openat -- open or create a file for reading or writing SYNOPSIS #include \u0026lt;fcntl.h\u0026gt; int open(const char *path, int oflag, ...); int openat(int fd, const char *path, int oflag, ...); DESCRIPTION The file name specified by path is opened for reading and/or writing, as specified by the argument oflag; the file descriptor is returned to the calling process. 在简介中有一段话：the file descriptor is returned to the calling process.\n使用 c 语言打开一个 文件\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int fd; fd = open(\u0026#34;tmp.txt\u0026#34;, O_RDONLY); printf(\u0026#34;%d\u0026#34;, fd); sleep(10); } 输出:\n3 而且我们在查看 /proc/{进程id}/fd/ 目录时会发现，会出现一个描述符 3 指向了 打开的文件\n$ ll /proc/$(ps aux | grep a.out | grep -v grep | awk \u0026#39;{print $2}\u0026#39;)/fd total 0 lrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 0 -\u0026gt; /dev/pts/4 lrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 1 -\u0026gt; /dev/pts/4 lrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 2 -\u0026gt; /dev/pts/4 lr-x------ 1 ubuntu ubuntu 64 Apr 13 13:48 3 -\u0026gt; /home/ubuntu/mydisk/yangblog/codes/file/tmp.txt 我们可以把这个 文件描述符当做参数传递给 read 或 write 等系统调用函数。\n","permalink":"https://wudanyang6.github.io/post/os/fd/","summary":"什么是文件描述符 对于内核而言，所有打开的文件都通过 文件描述符（file descriptor）引用。通常也写作 fd。\n文件描述符是一个非负整数。\n当打开一个现有文件或者创建一个新文件时，内核向进程返回一个 文件描述符。\n文件描述符是跟 进程相关联的。\n按照惯例，UNIX 系统将 fd 0 对应进程的标准输入， fd 1 对应进程的标准输出， fd 2 对应进程的标准错误。\n系统调用中的文件描述符 UNIX 系统中，一切皆文件，所以一切资源都可以使用文件描述符进程引用。\n以 open 系统调用为例\n使用 man 2 open 查看系统 man 手册\nNAME open, openat -- open or create a file for reading or writing SYNOPSIS #include \u0026lt;fcntl.h\u0026gt; int open(const char *path, int oflag, ...); int openat(int fd, const char *path, int oflag, ...); DESCRIPTION The file name specified by path is opened for reading and/or writing, as specified by the argument oflag; the file descriptor is returned to the calling process.","title":"文件描述符"},{"content":"原则 止损优先 不能先追查问题根源， 首先应该止损，不让问题进一步扩大，代码回滚、服务降级等都可以起到止损的效果。 对于止损有一个比较好的实践，新业务或者重构业务上线时，可以加一个 配置开关 控制是否启用逻辑，在发现有损时，可以及时关掉业务逻辑，比重新上线要快很多。\n及时通告 在问题发生之后，要及时对处理问题的过程进行通告。特别是应对线上有损的问题时，更应该及时通告。在内部群中，简单描述一下问题与可能的原因，处理的进度。而在外部群里，可以只说一下处理的进度。如果有必要，可以将问题上诉到领导，如果还解决不了问题，可以逐级继续上诉。\n追查问题的方法 逻辑方法: 先收集现象：业务报错、线上报错日志等 对紧急的问题来说，需要对线上业务、服务器等非常熟悉，才能迅速收集到有用的报错信息。 针对现象假设原因： 常见问题依据追查手册 其他问题保持思路开放，大胆假设 是否有损的判断： 根据现象假设出可能的原因，判断是否是有损的，如果是有损的问题，参考 止损优先 质疑所有数据： 各个数据、监控系统等的有效性也需要质疑，不能完全相信，需要小心求证 知识准备 对线上各种日志的熟悉，从日志中能看到具体的问题，比如 nginx 日志 php 日志等 对线上的各种配置更要做到心中有数 对细节的追查，每次都更细一些，这样才能获得更多的信息 计算机基本功，有时问题追查不下去，不是没有线索，而是追查到了一个未知的领域，没有相关的知识，无法追查 总结经验 成熟的方法落地成工具 对问题的追查形成文档 问题解决之后 如果问题解决之后，我们就不再跟进了，那么我们就沦为了解决问题的工具，问题也随之越来越多，解决不完。 那么，我们可以通过思考以下几点来提升自己\n线上是否恢复了正常？（基本） 问题的原因是什么？（形成记录） 通过什么手段恢复的？（解决方案） 怎么可以避免下次再次出现问题？（防患未然） 除了此次出现的问题，会不会有其他的问题出现（举一反三） 出现此类问题是否是架构问题造成的？（根本原因） ","permalink":"https://wudanyang6.github.io/post/exp/locate-online-error/","summary":"原则 止损优先 不能先追查问题根源， 首先应该止损，不让问题进一步扩大，代码回滚、服务降级等都可以起到止损的效果。 对于止损有一个比较好的实践，新业务或者重构业务上线时，可以加一个 配置开关 控制是否启用逻辑，在发现有损时，可以及时关掉业务逻辑，比重新上线要快很多。\n及时通告 在问题发生之后，要及时对处理问题的过程进行通告。特别是应对线上有损的问题时，更应该及时通告。在内部群中，简单描述一下问题与可能的原因，处理的进度。而在外部群里，可以只说一下处理的进度。如果有必要，可以将问题上诉到领导，如果还解决不了问题，可以逐级继续上诉。\n追查问题的方法 逻辑方法: 先收集现象：业务报错、线上报错日志等 对紧急的问题来说，需要对线上业务、服务器等非常熟悉，才能迅速收集到有用的报错信息。 针对现象假设原因： 常见问题依据追查手册 其他问题保持思路开放，大胆假设 是否有损的判断： 根据现象假设出可能的原因，判断是否是有损的，如果是有损的问题，参考 止损优先 质疑所有数据： 各个数据、监控系统等的有效性也需要质疑，不能完全相信，需要小心求证 知识准备 对线上各种日志的熟悉，从日志中能看到具体的问题，比如 nginx 日志 php 日志等 对线上的各种配置更要做到心中有数 对细节的追查，每次都更细一些，这样才能获得更多的信息 计算机基本功，有时问题追查不下去，不是没有线索，而是追查到了一个未知的领域，没有相关的知识，无法追查 总结经验 成熟的方法落地成工具 对问题的追查形成文档 问题解决之后 如果问题解决之后，我们就不再跟进了，那么我们就沦为了解决问题的工具，问题也随之越来越多，解决不完。 那么，我们可以通过思考以下几点来提升自己\n线上是否恢复了正常？（基本） 问题的原因是什么？（形成记录） 通过什么手段恢复的？（解决方案） 怎么可以避免下次再次出现问题？（防患未然） 除了此次出现的问题，会不会有其他的问题出现（举一反三） 出现此类问题是否是架构问题造成的？（根本原因） ","title":"如何追查线上问题"},{"content":"\n从网上找了一个非常好的图片，从图中可以看到很多东西\nNginx 会生成多个进程 worker 使用了io 多路复用的事件驱动框架 worker 内部有很多模块 worker 处理磁盘I/O 时，使用了标准I/O ，sendfile ，AIO ，mmap 等I/O 技术 Cache loader 和Cache manager 操作 proxy cache 后端支持多种基于tcp 的网络协议 ","permalink":"https://wudanyang6.github.io/post/nginx/nginx-process/","summary":"\n从网上找了一个非常好的图片，从图中可以看到很多东西\nNginx 会生成多个进程 worker 使用了io 多路复用的事件驱动框架 worker 内部有很多模块 worker 处理磁盘I/O 时，使用了标准I/O ，sendfile ，AIO ，mmap 等I/O 技术 Cache loader 和Cache manager 操作 proxy cache 后端支持多种基于tcp 的网络协议 ","title":"Nginx 进程模型-整体架构"},{"content":"歇一歇脚\n","permalink":"https://wudanyang6.github.io/post/hello-world/","summary":"歇一歇脚","title":"Hello World"}]