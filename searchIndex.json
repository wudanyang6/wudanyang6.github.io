[
{
		"title": "epoll的边缘触发和水平触发",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/100 Programmer/c/nginx/epoll的边缘触发和水平触发/",
		"content": "epoll的边缘触发和水平触发\nepoll 是 Linux 下用于处理大量文件描述符的高效 I/O 多路复用机制。在 epoll 中，有两种触发模式：水平触发（Level-Triggered，简称 LT）和边缘触发（Edge-Triggered，简称 ET）。\n\n水平触发（LT，Level-Triggered）：\n\n当文件描述符就绪时，epoll_wait 将立即返回。\n如果文件描述符的状态发生变化，epoll_wait 会再次通知应用程序。\n这种模式下，如果文件描述符有数据可读或可写，epoll_wait 将不停地返回通知，直到应用程序处理完数据或者阻塞。\n\n边缘触发（ET，Edge-Triggered）：\n\n当文件描述符就绪时，epoll_wait 只会通知一次，直到应用程序处理完数据并清空了文件描述符的缓冲区。\n如果文件描述符的状态没有变化，epoll_wait 不会重复通知应用程序。\n这种模式下，应用程序需要注意，在一个事件通知之后，要一直读或写，直到发生 EAGAIN 或 EWOULDBLOCK 错误。\n\n为什么epoll这里要叫做边缘触发和水平触发呢？\n这源于通信数字信号处理领域的术语，边缘和水平通常用于描述信号的特性\n\n边缘触发（Edge-Triggered）：\n\n&quot;边缘&quot; 指的是信号的变化边缘，即信号从一个状态变为另一个状态的瞬间。\n在数字信号处理中，边缘通常用来表示信号的上升沿或下降沿，即信号从低电平到高电平或从高电平到低电平的瞬间。\n\n水平触发（Level-Triggered）：\n\n&quot;水平&quot; 指的是信号的水平状态，即信号所处的电平状态。\n在数字信号处理中，水平触发通常用来描述信号保持在某个电平的状态，而不关心信号的变化瞬间。\n\nReference\nhttps://electronics.stackexchange.com/a/21891",
		"tags": [ "note"]
},

{
		"title": "Nginx 进程模型-整体架构",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/100 Programmer/c/nginx/nginx 进程模型-整体架构/",
		"content": "nginx 进程模型-整体架构\n\n从网上找了一个非常好的图片，从图中可以看到很多东西\n\nNginx 会生成多个进程\nworker 使用了 io 多路复用的事件驱动框架\nworker 内部有很多模块\nworker 处理磁盘 I/O 时，使用了标准 I/O ， sendfile ， AIO ，mmap 等 I/O 技术\nCache loader 和 Cache manager 操作 proxy cache\n后端支持多种基于 tcp 的网络协议",
		"tags": [ "note","nginx","Process"]
},

{
		"title": "vscode 调试nginx代码",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/100 Programmer/c/nginx/vscode 调试nginx代码/",
		"content": "#output\n内容\n修改 auto/cc/conf\nngx_compile_opt 中添加 -g\n修改后如下：\nngx_compile_opt=&quot;-c -g&quot;\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/100 Programmer/c/nginx/vscode 调试nginx代码/#gcc-g\">#gcc -g 的作用</a>\n编译 &amp; 安装 &amp; 运行\n# prefix 是想要安装到的目录\nauto/configure --prefix=/home/ubuntu/mydisk/var/nginx-debug-1\n\n# 编译安装\nmake\nmake install\n\n修改配置\nvim /home/ubuntu/mydisk/var/nginx-debug-1/conf/nginx.conf\n将监听端口号改成 8080\nworker_processes 改成 1 (方便调试)\n启动 nginx\n/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\nnginx 的进程：\nps aux | grep nginx\nubuntu 17093 0.0 0.0 4184 372 ? Ss Mar30 0:00 nginx: master process /home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\nubuntu 17094 0.0 0.0 4620 2316 ? S Mar30 0:00 nginx: worker process\nubuntu 46072 0.0 0.0 7692 648 pts/0 S+ 11:21 0:00 grep --color=auto nginx\n\n配置 vscode 调试\n{\n// 使用 IntelliSense 了解相关属性。\n// 悬停以查看现有属性的描述。\n// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n&quot;version&quot;: &quot;0.2.0&quot;,\n&quot;configurations&quot;: [\n{\n&quot;name&quot;: &quot;debug master&quot;,\n&quot;type&quot;: &quot;cppdbg&quot;,\n&quot;request&quot;: &quot;launch&quot;,\n&quot;program&quot;: &quot;/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx&quot;,\n&quot;args&quot;: [],\n&quot;stopAtEntry&quot;: true,\n&quot;cwd&quot;: &quot;${workspaceFolder}&quot;,\n&quot;environment&quot;: [],\n&quot;externalConsole&quot;: false,\n&quot;MIMode&quot;: &quot;gdb&quot;,\n&quot;setupCommands&quot;: [\n{\n&quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,\n&quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n&quot;ignoreFailures&quot;: true\n}\n]\n},\n{\n&quot;name&quot;: &quot;debug worker&quot;,\n&quot;type&quot;: &quot;cppdbg&quot;,\n&quot;request&quot;: &quot;attach&quot;,\n&quot;program&quot;: &quot;/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx&quot;,\n&quot;processId&quot;: 17094,\n&quot;MIMode&quot;: &quot;gdb&quot;,\n&quot;setupCommands&quot;: [\n{\n&quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,\n&quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n&quot;ignoreFailures&quot;: true\n}\n]\n}\n]\n}\n\n在 worker 上调试需要改成 attach 的形式，并且使用了一次 attach 之后，就不能使用 strace -p 17094 查看系统调用了\n然后就可以打断点，进行单步调试了\n参考\nMac上用Visual Studio Code调试Nginx\ngcc -g 的作用\nGCC 参数详解-runoob\n在编译的时候会产生调试信息\nkernel.yama.ptrace_scope\nsysctl -a 查看内核参数\nkernel.yama.ptrace_scope\nhttps://www.kernel.org/doc/Documentation/security/Yama.txt\nsudo vim /etc/sysctl.d/10-ptrace.conf\nVSCode调试出现无法打开glibc库的“raise.c“或“abort.c“等文件的错误\nsudo strace 报 操作不被允许\nsudo strace -p 17094\nstrace: Could not attach to process. If your uid matches the uid of the target process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try again as the root user. For more details, see /etc/sysctl.d/10-ptrace.conf: Operation not permitted\nstrace: attach: ptrace(PTRACE_SEIZE, 17094): Operation not permitted\n\nhttps://stackoverflow.com/questions/19215177/how-to-solve-ptrace-operation-not-permitted-when-trying-to-attach-gdb-to-a-pro\nMaybe someone has attached this process with gdb.\n\nps -ef | grep gdb\n\ncan't gdb attach the same process twice.\n将 vscode 中的 调试关掉，就可以使用 strace 了\n如下图，可以看到，子进程停在了 epoll_pwait 系统调用上了",
		"tags": ["output", "gcc", "note"]
},

{
		"title": "如何查看 nginx 的rewrite记录",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/100 Programmer/c/nginx/如何查看 nginx 的rewrite记录/",
		"content": "如何调试nginx的rewrite规则？\n设置 rewrite_log on;\n并且将error_log 的报错等级改成 notice;\n官网对 rewrite_log 的解释：\nSyntax:\trewrite_log on | off;\nDefault:\t\nrewrite_log off;\nContext:\thttp, server, location, if\nEnables or disables logging of ngx_http_rewrite_module module directives processing results into the error_log at the notice level.\n\n可以看到，这个指令只能在 http server location if 配置指令中使用，日志等级是 notice 写入到 error_log 配置的文件中。\n示例\nurl： /q?someparams\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+m/question(.*)?qid=\\d+(.*)?$&quot; does not match ...\n... 中间省略一些日志\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+question/(\\w+.*?)$&quot; does not match ...\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+q\\?(.*)?tn=nsatom_qb_main(.*)?$&quot; matches ...\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+q&quot; matches ...\n2021/04/22 18:21:28 [notice] 18131#0: *102982 rewritten data: &quot;/q/q/q/q/q&quot;\n\n从上面的日志中可以看出，当触发了重写规则时，会有关键字 matches 否则会有 does not match 。\n最终重写完成之后，访问的地址会有标记：rewritten data\n这里就是 /q/q/q/q/q\n参考\nbest way to debug nginx rewrite rules in config file?\nnginx官方文档：Module ngx_http_rewrite_module",
		"tags": [ "note"]
},

{
		"title": "ubuntu 树莓派启动时配置网络",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/100 Programmer/linux/树莓派/ubuntu 树莓派启动时配置网络/",
		"content": "树莓派 ubuntu 配置网络\n树莓派现在可以安装很多操作系统，其中 ubuntu 也提供了树莓派版本，因为对 ubuntu 更加熟悉，所以就往 SD 卡中烧录了 ubuntu 的 20.04 lts 64位 版本。这里有可供选择的操作系统。\n简单提一嘴烧录操作系统到 SD 卡上面的方法，树莓派提供了一个傻瓜式的软件给大家使用，直接打开之后选择系统，就可以烧录了，烧录过程大概会有几分钟。\n烧录完成之后，如果你按照树莓派官网的教程进行操作，肯定都行不通，因为树莓派的官方操作系统 Raspberry Pi OS 和 Ubuntu For Raspberry 上面的网络配置方式完全不一样。\n安装了 ubuntu 的树莓派怎么配置网络？\n打开你烧录好的 SD 卡\n找到 network-config 文件\n写入如下配置：\nwifis:\nwlan0:\ndhcp4: true\noptional: true\naccess-points:\n&lt;wifi network name&gt;:\npassword: &quot;&lt;wifi password&gt;&quot;\n\n如果是企业网络：\nwifis:\nwlan0:\ndhcp4: true\noptional: true\naccess-points:\n&lt;wifi network name&gt;:\nauth:\nkey-management: eap\nmethod: peap\nidentity: &quot;wudanyang&quot;\npassword: &quot;&quot;\n\n配置文件的格式\n修改完之后，把 SD 卡从电脑上弹出，然后插到树莓派里。\n不过，重启之后，你可能还是无法连接到网络。可以看下这里\n\nNote: During the first boot, your Raspberry Pi will try to connect to this network. It will fail the first time around. Simply reboot sudo reboot and it will work.\n\n引用ubuntu官网的一段话，第一次会失败，直接重启，第二次就能连上了。\n开启网络之后，如何登录树莓派？\n安装好之后默认用户名和密码都是 ubuntu\nssh ubuntu@&lt;raspberry ip&gt;\nip 地址的获取这里列举几种方法，不详细介绍：\n\n自己的路由器：登录后台查看分配的 ip\n局域网扫描（局域网机器不多的情况下）：\n\n下载个局域网扫描工具，如果局域网机器不多，会看到一个制造商为树莓派的 ip\n使用命令行 arp -a 挨个试一下\n\nubuntu 启动之后会使用 avahi 服务通过 mdns 协议在局域网注册一个域名 ubuntu.local，所以你可以这样登录 ssh ubuntu@ubuntu.local\n\n参考\n树莓派支持的操作系统\n树莓派操作系统烧录软件\n无屏幕和键盘配置树莓派WiFi和SSH\n百度百科-mdns\nMac通过网线直连控制树莓派 - lonerpaul - 博客园",
		"tags": [ "note"]
},

{
		"title": "Site Home dy_turbo",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "What are you doing\n千里之行，始于足下\nList\n\nFile\nCreated\nModified\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/obsidian/obsidian-things3-today插件/\">obsidian-things3-today插件</a>\n2024-01-29星期1 14:23\n2024-01-29星期1 14:27\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/100 Programmer/c/nginx/epoll的边缘触发和水平触发/\">epoll的边缘触发和水平触发</a>\n2024-01-28星期7 22:53\n2024-01-29星期1 11:21\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/\">Site Home dy_turbo</a>\n2024-01-28星期7 22:46\n2024-01-29星期1 14:38\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/100 Programmer/linux/树莓派/ubuntu 树莓派启动时配置网络/\">ubuntu 树莓派启动时配置网络</a>\n2021-04-27星期2 23:13\n2024-01-29星期1 14:37\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/100 Programmer/c/nginx/如何查看 nginx 的rewrite记录/\">如何查看 nginx 的rewrite记录</a>\n2021-04-22星期4 18:14\n2024-01-28星期7 23:38\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/100 Programmer/c/nginx/nginx 进程模型-整体架构/\">nginx 进程模型-整体架构</a>\n2021-04-14星期3 13:14\n2024-01-29星期1 14:36\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/output/文件描述符/\">文件描述符</a>\n2021-04-13星期2 11:24\n2024-01-29星期1 14:34\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/100 Programmer/c/nginx/vscode 调试nginx代码/\">vscode 调试nginx代码</a>\n2021-03-25星期4 19:13\n2024-01-28星期7 23:57\n\nmusic",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "obsidian-things3-today插件",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/obsidian/obsidian-things3-today插件/",
		"content": "obsidian-things3-today插件\n把之前的插件重新搞了搞，把乱七八糟的东西去掉了，然后提交了obsidian插件库\n正在等着被review： https://github.com/obsidianmd/obsidian-releases/pull/2997\n新录了一个gif：\n图中可以看到和things3的Today列表联动还算是顺畅\n\nReference",
		"tags": [ "note"]
},

{
		"title": "文件描述符",
		"date":"Mon Jan 29 2024 06:44:04 GMT+0000 (Coordinated Universal Time)",
		"url":"/output/文件描述符/",
		"content": "什么是文件描述符\n对于内核而言，所有打开的文件都通过文件描述符（file descriptor）引用。通常也写作 fd。\n文件描述符是一个非负整数。\n当打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n文件描述符是跟进程相关联的。\n按照惯例，UNIX 系统将 fd 0 对应进程的标准输入， fd 1 对应进程的标准输出， fd 2 对应进程的标准错误。\n系统调用中的文件描述符\nUNIX 系统中，一切皆文件，所以一切资源都可以使用文件描述符进程引用。\n以 open 系统调用为例\n使用 man 2 open 查看系统 man 手册\nNAME\nopen, openat -- open or create a file for reading or writing\n\nSYNOPSIS\n#include &lt;fcntl.h&gt;\n\nint\nopen(const char *path, int oflag, ...);\n\nint\nopenat(int fd, const char *path, int oflag, ...);\n\nDESCRIPTION\nThe file name specified by path is opened for reading and/or writing,\nas specified by the argument oflag; the file descriptor is returned to\nthe calling process.\n\n在简介中有一段话：the file descriptor is returned to the calling process.\n使用 c 语言打开一个 文件\n#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n\tint fd;\n\tfd = open(&quot;tmp.txt&quot;, O_RDONLY);\n\tprintf(&quot;%d&quot;, fd);\n\tsleep(10);\n}\n\n会发现，在进程运行时 fd 目录下，会出现一个描述符 3 指向了 打开的文件\n$ ll /proc/$(ps aux | grep a.out | grep -v grep | awk '{print $2}')/fd\ntotal 0\nlrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 0 -&gt; /dev/pts/4\nlrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 1 -&gt; /dev/pts/4\nlrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 2 -&gt; /dev/pts/4\nlr-x------ 1 ubuntu ubuntu 64 Apr 13 13:48 3 -&gt; /home/ubuntu/mydisk/yangblog/codes/file/tmp.txt\n\n我们可以把这个文件描述符当做参数传递给 read 或者 write 等等系统调用。",
		"tags": ["include", "include", "include", "include", "note","文件","OS","linux"]
}
]