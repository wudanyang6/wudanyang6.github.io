[
{
		"title": "2024-10-11",
		"date":"Fri Oct 11 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/journal/2024-10-11/",
		"content": "2024-10-11\n换了一个新的工作电脑 Apple M3 16G\n新电脑的刘海把很多图标都挡住了，太难受了，看网上教程，找了个软件 Bartender 能够解决\n带刘海屏的 Macbook, 状态栏图标多了被刘海挡住看不到了，咋办？ - V2EX: https://v2ex.com/t/1019165#;",
		"tags": [ "note"]
},

{
		"title": "202404151418 哲学",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/000 Topic Index/202404151418 哲学/",
		"content": "202404151418 哲学\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/20240415183533 哲学书单/\">20240415183533 哲学书单</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/哲学/202404151420 哲学的分支/\">202404151420 哲学的分支</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/thoughts/20240415141933 什么是哲学/\">20240415141933 什么是哲学</a>",
		"tags": [ "note","index","哲学"]
},

{
		"title": "202404151422 游戏",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/000 Topic Index/202404151422 游戏/",
		"content": "202404151422 游戏\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/20240415142052 原神挺好玩/\">20240415142052 原神挺好玩</a> 不怎么玩了\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/20240417125706 部落冲突/\">20240417125706 部落冲突</a> 已经不玩了\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">剑与远征：启程</a> 正在玩，挂机游戏",
		"tags": [ "note","index"]
},

{
		"title": "20240416231513 卡片盒笔记法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/000 Topic Index/笔记方法/20240416231513 卡片盒笔记法/",
		"content": "20240416231513 卡片盒笔记法\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011192022 - 什么是卡片盒笔记法/\">202011192022 - 什么是卡片盒笔记法</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011192023 - 卡片盒笔记法的基本元素/\">202011192023 - 卡片盒笔记法的基本元素</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011201016 - 什么是知识和信息/\">202011201016 - 什么是知识和信息</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011201301 - 基础概念/\">202011201301 - 基础概念</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011201315 - 卡片盒笔记法主要关注什么/\">202011201315 - 卡片盒笔记法主要关注什么</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011210003 - 卡片盒笔记法的基本流程/\">202011210003 - 卡片盒笔记法的基本流程</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011220028 - 从输出的角度看卡片盒笔记法的优势/\">202011220028 - 从输出的角度看卡片盒笔记法的优势</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011222209 - 卡片盒笔记法的步骤/\">202011222209 - 卡片盒笔记法的步骤</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011222310 - 卡片盒笔记法的模块/\">202011222310 - 卡片盒笔记法的模块</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011222324 - 知识/\">202011222324 - 知识</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011222325 - 信息/\">202011222325 - 信息</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011222338 - 使用卡片盒笔记法输出的流程/\">202011222338 - 使用卡片盒笔记法输出的流程</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011230004 - 如何写出容易理解的卡片/\">202011230004 - 如何写出容易理解的卡片</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/20240408201701 卡片盒笔记法/\">20240408201701 卡片盒笔记法</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/生成/\">生成</a>\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">202404081646 卡片笔记应该记录什么</a>\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">202404081701 针对过时的想法怎么处理</a>\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">202404081818 为什么建立笔记时要指明原因</a>",
		"tags": [ "note"]
},

{
		"title": "Home",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "愿国泰民安、风调雨顺、世界和平\n\n听首歌吧\n\n平时要全力以赴的练习，才能在关键时刻派上用场",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "20240415142052 原神挺好玩",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/20240415142052 原神挺好玩/",
		"content": "20240415142052 原神挺好玩\n最近游戏一直在玩原神，一个开放的大世界。主线剧情刚刚做完，确实是我想象中的角色扮演（RPG）游戏。\n记得高中在塞班手机上玩的一款RPG游戏，一个周末都在刷怪。后来重新练了个号，结果跟大师傅打架的时候，他的70级宠物不知道为什么变成我的了。我就带着一个70级将近满级的宠物一路过关斩将玩通关了。\n原神里面我自己感觉可玩的点有几个：\n\n角色都很二次元，都是按照动漫里面的角色画出来的，二次元的估计会很喜欢。\n剧情比较代入，某些剧情需要努力打怪，不过主线剧情并不是很难。\n大世界地图非常大，如果不是有传送节点估计跑图都得跑断腿。\n大世界里面有很多宝箱，有些宝箱需要解密之后才能获得，不过这些宝箱都是一次性的，我在蒙德、璃月、稻妻的探索度最高才到 50% ，所以也可见大世界有多大东西有多丰富。\n支线剧情也很丰富多彩，比如我就特别喜欢璃月里面的一个支线剧情《神女劈观》，并且剧情最后有一首歌，大家可以先听一下。不过没有了解剧情之前听这首歌触动应该不是很大，还是具体体验一下剧情再说。点击可播放：\n最后一点，原神不花钱氪金也可以玩的很舒服，每天做做每日任务，开开宝箱，欣赏欣赏美景，然后读一读角色的背景故事。\n\n对了，游戏社区里的前辈忠告，当深渊不存在，能打到哪里就打到哪里。",
		"tags": [ "note"]
},

{
		"title": "20240415183533 哲学书单",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/20240415183533 哲学书单/",
		"content": "20240415183533 哲学书单\n哲学书单最全102本，哲学入门到进阶必读！北大武大哲学系推荐 - 知乎: https://zhuanlan.zhihu.com/p/72569441",
		"tags": [ "note"]
},

{
		"title": "20240417103919 卡片盒笔记法的标题是对内容的一句话描述",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/20240417103919 卡片盒笔记法的标题是对内容的一句话描述/",
		"content": "20240417103919 卡片盒笔记法的标题是对内容的一句话描述\n补充 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011192023 - 卡片盒笔记法的基本元素/\">202011192023 - 卡片盒笔记法的基本元素</a>",
		"tags": [ "note"]
},

{
		"title": "20240417125706 部落冲突",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/20240417125706 部落冲突/",
		"content": "20240417125706 部落冲突\n部落冲突玩到13本了，原来部落联盟的人都没了，然后也没有什么动力能继续玩下去，就这样偶尔上线一次了",
		"tags": [ "note"]
},

{
		"title": "About Me",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/About Me/",
		"content": "About Me\ngithub 个人主页\n1. music",
		"tags": [ "note"]
},

{
		"title": "CDN 带宽控制的几种方法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/CDN 带宽控制的几种方法/",
		"content": "CDN 带宽控制的几种方法\n\nrefer 限制，禁用非自身域名\n\n空refer禁用，有一定风险，尽量在站点刚开放时使用此方案\n\n单请求响应限速，百度CDN可以配置\nCDN日志回扫分析\n\n删除肉眼可见的违规图片\n对图片进行检测，是否包含视频资源（需要一定的策略支持）\n\n针对访问量、请求数过高的ip进行封禁\n图片与内容关联，在审核内容时，发现图片违禁直接删除内容并删除图片",
		"tags": [ "note"]
},

{
		"title": "DoD",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/DoD/",
		"content": "DoD\n什么是Dod（Definition of Done，完成的定义）\nDoD 是一个清单，清单是由一个个的检查项组成的，用来检查我们的工作完成情况。\nDoD 的检查项应该是实际可检查的。\nDoD 是团队成员间彼此汇报的一种机制。\n\n对齐机制\n完成标准\n\nDoD列表\n需求准入完成-DoD\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">需求评审完成-DoD</a>\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">开发完成-DoD</a>\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">需求完成-DoD</a>\nReference\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/工具/10x程序员工作法/\">10x程序员工作法</a>\nhttps://learn.lianglianglee.com/专栏/10x程序员工作法/03 DoD的价值：你完成了工作，为什么他们还不满意？.md",
		"tags": [ "note"]
},

{
		"title": "Kafka入门",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/Kafka入门/",
		"content": "Kafka 入门\n1.1 什么是 Kafka\nApache Kafka 是一个分布式流处理平台，被设计用来高效地处理高吞吐量的数据流。它广泛应用于实时数据管道和流式应用程序中。以下是 Kafka 的一些主要优点：\n\n高吞吐量：Kafka 支持高吞吐量的数据处理，即使是非常大的数据量也能够快速处理。\n可扩展性：Kafka 集群可以横向扩展以处理更多的数据，可以在不停机的情况下动态添加更多的 Broker。\n持久性和可靠性：Kafka 可以将数据持久化到磁盘，因此即使系统发生故障，数据也不会丢失。它使用分区和副本机制来确保数据的高可用性和耐用性。\n容错能力：通过数据副本，Kafka 可以在节点故障时保证数据不丢失，从而提供高可靠性。\n低延迟：Kafka 能够在保持高吞吐量的同时实现低延迟的消息传递。\n可靠的消息传递保证：Kafka 支持几种消息传递保证，包括最多一次、至少一次和精确一次（事务性传递）。\n多客户端支持：Kafka 提供多种编程语言的客户端库，方便不同开发环境下的集成。\n流处理：Kafka Streams API 允许构建实时流处理应用，可以进行复杂的数据处理和分析。\n可观测性：Kafka 提供了监控数据流和系统性能的工具，有助于性能调优和问题诊断。\n大型社区和生态系统：Kafka 拥有一个庞大的社区和丰富的生态系统，提供了大量的工具和插件以及集成方案，可以帮助用户更好地开发和维护 Kafka 系统。\n\n1.2 使用场景\nKafka 的这些优点使它在需要处理大量实时数据的系统中特别有价值，包括日志聚合、流式处理、事件源、实时监控和分析等场景。\n\n1.3 kafka 生产消费流程\n\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">../100 Programmer/mac 运行 kafka</a>\n2 Kafka 整体架构\n\nKafka 系统的核心概念包括：\n\nProducer（生产者）：负责发布消息到 Kafka 的 Topic（主题）中。\nConsumer（消费者）：订阅 Topic，并处理发布到这些 Topic 的消息。\nConsumer Group（消费者组）：一个消费者组可以有一个或多个消费者实例。当多个消费者实例属于同一个消费者组时，它们会在组内共享 Topic 的 Partition。这意味着，每个 Partition 只会被消费者组中的一个消费者实例消费，这样可以保证每条消息只被组内的一个消费者处理，从而实现消息的负载均衡。\nBroker（代理）：Kafka 集群中的服务器，负责存储数据并处理 Producer 和 Consumer 的请求。\nTopic（主题）：消息的分类，Producer 发布消息到指定的 Topic，Consumer 订阅并消费 Topic 中的消息。\nPartition（分区）：Topic 的物理分割，每个 Partition 在存储层面是独立的，可以在不同的 Broker 上。Partition 内的消息是有序的。\nOffset（偏移量）：Partition 中每条消息的唯一标识，可以看作是消息在 Partition 中的索引。\nReplica（副本）：Partition 的副本，用于提高数据的可靠性和容错性。\nZookeeper：Kafka 使用 Zookeeper 来进行集群管理和协调。\nStream Processing（流处理）：Kafka Streams 是 Kafka 的流处理库，用于构建流式应用程序。\nConnect（连接器）：Kafka Connect 是用于构建和运行可重用的数据导入和导出连接器的工具。\n\nKafka 生产者将消息发送到负责存储目标 Topic 的 Partition 的 Broker 上。在 Kafka 集群中，每个 Topic 可以分为多个 Partition，而每个 Partition 可能分布在不同的 Broker 上。每个 Partition 有一个 Broker 充当 Leader，其他的 Broker 充当 Follower。所有的读写操作都是通过 Leader Broker 进行的，Follower 负责同步数据以保证高可用性和数据的冗余。\n3 Kafka 核心逻辑\n3.1 物理存储\nKafka 的基本存储单元是分区。\n\nkafka 存储的时候也是使用同样的格式存储到磁盘上，这样可以利用到零拷贝技术\n3.2 生产者\n\n流程如下：\n\n首先，我们需要创建一个 ProducerRecord，这个对象需要包含消息的主题（topic）和值（value），可以选择性指定一个键值（key）或者分区（partition）。\n发送消息时，生产者会对键值和值序列化成字节数组，然后发送到分配器。\n如果我们指定了分区，那么分配器返回该分区即可；否则，分配器将会基于键来选择一个分区并返回。\n选择完分区后，生产者知道了消息所属的主题和分区，它将这条记录添加到相同主题和分区的同一批次消息中，另一个线程负责发送这些批量消息到对应的 Kafka Broker。\n当 Broker 接收到消息后，如果成功写入则返回一个包含消息的主题、分区及位移的 RecordMetadata 对象，否则返回异常。\n生产者接收到结果后，对于异常可能会进行重试。重试几次还是失败会返回错误。\n\n生产者并不是将消息发送到任意的 Broker，而是发送到管理特定 Partition 的 Leader Broker 上，以确保消息的正确存储和分发。\n消息写入多个分区\n\n3.3 消费者\n\n3.3.1 提交 offset\nKafka 消费者提交偏移量的过程是为了记录消费者在消费 Topic 的 Partition 时当前的位置，以便在消费者重启或发生故障时能从上次处理的位置继续消费，保证消息不会丢失也不会被重复消费。提交偏移量的过程主要包括以下步骤：\n\n消费消息：消费者从 Broker 拉取数据并进行处理。\n提交偏移量：在成功处理完一批消息后，消费者会将最新的偏移量提交给 Kafka。提交的偏移量是消费者下一次预期读取的起始位置。\n偏移量存储：提交的偏移量存储在 Kafka 内的一个特殊的 Topic 中，名为 __consumer_offsets。每个消费者组的偏移量都会在这个 Topic 中维护。\n偏移量读取：如果消费者发生重启或故障，它会从 __consumer_offsets Topic 中读取上次提交的偏移量，从而恢复其消费状态。\n\n提交偏移量的方式主要有两种：\n\n自动提交偏移量：Kafka 消费者默认的偏移量提交方式是自动提交。这是通过在消费者配置中设置 enable.auto.commit=true 来实现的，并且可以通过 auto.commit.interval.ms 配置项来指定提交间隔。这种方式简单方便，但是由于提交是周期性进行的，可能会导致消息重复消费（如果在两次提交间隔内消费者失败）。\n手动提交偏移量：为了更精确地控制消息的消费状态，可以选择手动提交偏移量。手动提交可以是同步的也可以是异步的：\n\n同步提交：通过调用 consumer.commitSync() 方法，消费者会阻塞直到偏移量提交完成。这种方式会确保偏移量提交成功，如果提交失败，可以立即进行重试处理。\n异步提交：通过调用 consumer.commitAsync() 方法，消费者可以在不阻塞当前线程的情况下提交偏移量。异步提交通常会提供一个回调函数来处理可能发生的提交错误。\n异步 + 同步：针对异步提交偏移量丢失的问题，通过对消费者进行异步批次提交并且在关闭时同步提交的方式，这样即使上一次的异步提交失败，通过同步提交还能够进行补救，同步会一直重试，直到提交成功。\n\n3.4 复制\n3.4.1 控制器\n有一个概念需要单独阐明：控制器\n控制器其实就是一个 Broker，只不过它除了具有一般 Broker 的功能之外，还负责分区首领的选举。\n控制器是 Kafka 集群的管理节点。在一个 Kafka 集群中，所有的 Broker 节点中只有一个节点会被选举为控制器。\n每个新选出的控制器通过 Zookeeper 的条件递增操作获得一个全新的、数值更大的 epoch 值，防止脑裂\n简而言之，Kafka 使用 Zookeeper 的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行分区首领选举。控制器使用 epoch 来避免“脑裂”。“脑裂”是指两个节点同时认为自己是当前的控制器。\n3.4.2 与首领保持一致\n为了与首领保持同步，跟随者向首领发送获取数据的请求，这种请求与消费者为了读取消息而发送的请求是一样的。首领将响应消息发给跟随者。请求消息里包含了跟随者想要获取消息的偏移量，而且这些偏移量总是有序的。\n3.5 处理请求\n\nKafka 使用零复制技术向客户端发送消息——也就是说，顺序读写内容，Kafka 直接把消息从文件 (或者更确切地说是 Linux 文件系统缓存) 里发送到网络通道，而不需要经过任何中间缓冲区。\n零拷贝示意图：\n\n零拷贝省略了数据在内核空间和用户空间之间的重复穿梭；用户态和内核态切换时产生中断，耗时；\n生产请求和获取请求都必须发送给分区的首领副本。\n如何获取分区首领所在的 broker：\n\n4 可靠性保证\n先了解一个概念：不完全的首领选举\n4.1 消息传递语义\n\n最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。\n\n消费者端配置自动提交偏移量，并且在处理消息之前就提交。如果在提交偏移量后处理消息时发生了故障，那么这些消息可能不会被重新消费。\n\n至少一次（at least once）：消息不会丢失，但有可能被重复发送。\n\n手动提交偏移量。如果消费者在成功处理消息之前失败，那么同一消息可能会被再次消费。\n\n恰好一次（exactly once）：消息不会丢失，也不会被重复发送。\n\nKafka 通过“幂等生产者”（Idempotent Producer）和“事务”（Transactions）来支持恰好一次的语义。幂等生产者确保即使生产者发送重复的消息，Broker 也只会接收一次。事务性生产者可以将消息的发送和偏移量的提交放在同一个事务中，确保它们要么都成功，要么都失败。（恰好一次语义在 Kafka 0.11 版本及以上被引入。）\n\n4.2 不完全的首领选举\n是否允许不完全的首领选举：unclean.leader.election\n如果在选举过程中没有丢失数据，也就是说提交的数据同时存在于所有的同步副本上，那么这个选举就是“完全”的。\n如果在首领不可用时其他副本都是不同步的，那么这个选举就是“不完全”的。\n简而言之，如果我们允许不同步的副本成为首领，那么就要承担丢失数据和出现数据不一致的⻛险。如果不允许它们成为首领，那么就要接受较低的可用性，因为我们必须等待原先的首领恢复到可用状态。\nunclean.leader.election=false\n4.3 复制\n复制系数\nreplication.factor &gt;= 2\nmin.insync.replicas &gt; 1 则至少有一个同步从副本\n4.4 使用生产者\n发送确认：\n\nacks=0 立即返回，不论是否写入\nacks=1 当前首领副本已经写入\nacks=-1 或 all 所有同步的副本已经被写入\n\n重试\n\n配置重试次数\n设置重试间隔\n程序兜底其他错误\n\n4.5 使用消费者\n如果消费者提交了偏移量却未能处理完消息，那么就有可能造成消息丢失，这也是消费者丢失消息的主要原因。\n正确的做法是：拉取数据、业务逻辑处理、提交消费 Offset 位移信息。\nenable.auto.commit = false 采用手动提交位移的方式。\n对于消费消息重复的情况，业务自己保证幂等性， 保证只成功消费一次即可。\n6 思考\nQ: 知道了 kafka 的物理存储的结构，那么 kafka 通过 offset 查找对应的文件位置的过程是什么样的呢？\nQ: 从副本在什么情况下被认为是不同步 (OSR) ？\nQ: offset 为什么要从 zookeeper 挪到 kafka 本身存储呢？\nQ：分区分成多少比较好？\nQ：在主题流量不是很大的情况下，消费者一直轮询会造成浪费，有没有什么方式能够避免这种情况？\nQ：Kafka 为什么要把自己定位成一个分布式流平台？\n7 参考\n《Kafka 权威指南》 Neha Narkhede Gwen Shapira Todd Palino 著 薛命灯译\n官网文档： Apache Kafka\nmac环境下使用brew安装Kafka(详细过程)_brew kafka-CSDN博客\nKafka整体架构、工作流程与文件存储机制 - 细雨骑驴入剑门 - 博客园\n扫盲Kafka？看这一篇就够了！ - 京东云技术团队 - 博客园\nKafka元数据缓存(metadata cache) - huxihx - 博客园\nKafka 物理存储机制 - Java程序员进阶 - 博客园\n稀疏索引与其在Kafka和ClickHouse中的应用-腾讯云开发者社区-腾讯云\n8张图带你全面了解kafka的核心机制 - JAVA旭阳 - 博客园\n进阶，Kafka 如何保证消息不丢失？ - 知乎\nKafka的自我定位",
		"tags": [ "note"]
},

{
		"title": "202011261547 - 使用base64处理二进制字符串",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/Linux/202011261547 - 使用base64处理二进制字符串/",
		"content": "tags: #string\n一句话简单描述：使用 base64_encode 将二进制字符串映射成 base64 ， 然后在使用的使用 base64_decode 一下\n202011261547 - 使用base64处理二进制字符串\n二进制字符串不具有可处理性，输出到文件或者屏幕上面显示如下:\n\n上面图片中的字符串很难被处理，因为二进制字符串在\nbase64_encode 之后，是使用64个字符组成的字符串：\n\n程序中处理的时候使用 base64_decode 一下，赋值给一个变量即可\n$originData = base64_deocde($base64Data);\n\n# 下面是你自己的逻辑\n......",
		"tags": ["string", "note","linux"]
},

{
		"title": "202103251606 - 如何在 linux 上配置科学上网",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/Linux/202103251606 - 如何在 linux 上配置科学上网/",
		"content": "202103251606 - 如何在 linux 上配置科学上网\n我的机器是树莓派，底层架构是 arm 的，所以下载 arm 版本的安装包：\nhttps://github.com/Dreamacro/clash/releases/download/v1.4.2/clash-linux-armv8-v1.4.2.gz\ngunzip clash-linux-armv8-v1.4.2.gz\nsudo mv clash-linux-armv8-v1.4.2 /usr/bin/clash\n\n# 下载你的配置，这里我是用的是 nsfwcloud.com 的服务\nwget -O config.yml &quot;https://rxl-nc.xyz/link/{your.token}?clash=1&amp;log-level=info&quot;\n\n# 后台运行\nnohup clash -f config.yml &amp;\n\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\n最终效果\n\n如果不想要 info 日志，可以在 config.yml 中将 log-level 修改成 log-level: warning\n参考\nhttps://nsfwcloud.com/user/tutorial?os=linux&amp;client=clash##\noutput\nhttps://www.cnblogs.com/wudanyang/p/15142036.html",
		"tags": [ "note","linux"]
},

{
		"title": "202404142147 如何在shell中遍历数字",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/Linux/202404142147 如何在shell中遍历数字/",
		"content": "202404142147 如何在shell中遍历数字\nfor i in {0..10}; do\necho ${i}\ndone\n\n# seq 1 3 10 # 步长3\nfor i in $(seq 1 10); do\n\techo ${i}\ndone\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/shell-循环/\">shell-循环</a>",
		"tags": [ "note"]
},

{
		"title": "PHP生成zip压缩包",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/PHP生成zip压缩包/",
		"content": "PHP生成zip压缩包\n将文件压缩成zip格式\n&lt;?php\n$path = &quot;file.txt&quot;;\n$filename = &quot;file.zip&quot;;\n\n$zip = new ZipArchive();\n$zip-&gt;open($filename, ZipArchive::CREATE); //打开压缩包\n$zip-&gt;addFile($path, basename($path)); //向压缩包中添加文件\n$zip-&gt;close(); //关闭压缩包",
		"tags": [ "note","php","压缩"]
},

{
		"title": "202408312248 甲沟炎的处理办法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/Personal/202408312248 甲沟炎的处理办法/",
		"content": "202408312248 甲沟炎的处理办法\n\n去修脚店：有的店承诺修好，费用会贵一些，但是后续修就不要钱了，在北京顺义这边大概一只脚趾需要600块钱。我是两个大拇脚趾，当时应该花了1200，后续一两年内去了很多次，没有另收费。在这之前我去过很多次其他的店，每次修脚都需要一二百块钱。\n去医院拔掉：去过一次医院，医生不建议拔掉，因为拔掉不能保证以后新长出来的不会出现甲沟炎，并且恢复期很长。医生建议是买点消炎的药，等趾甲顶出来以后就好了。我的趾甲太硬，等了一个月，除了疼之外，没有见半点能顶出来的迹象，所以又去了修脚店清理掉了。\n后来突发奇想，在网上买了一个指甲锉，每次疼了就用这个指甲锉磨一磨，竟然神奇的没有再去过修脚店，而且左边的趾甲经过我的良好引导已经不往肉里长了。\n有需要的可以试试： https://item.jd.com/100015138940.html",
		"tags": [ "note","甲沟炎"]
},

{
		"title": "alfred-翻译插件",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/alfred-翻译插件/",
		"content": "alfred-翻译插件\n按照这个文章的步骤就可以创建一个应用\nhttps://github.com/wensonsmith/YoudaoTranslate",
		"tags": [ "note"]
},

{
		"title": "digital-garden 在 windows 上面 diff 出错",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/digital-garden 在 windows 上面 diff 出错/",
		"content": "digital-garden 在 windows 上面 diff 出错\nhttps://github.com/oleeskild/obsidian-digital-garden\nobsidian 插件 digital-garden 在windows上面有个 bug，会将我的 frontmatter 全部透传\n推到代码库中是这样的： https://github.com/wudanyang6/dy_turbo/commit/7b66296c349fb067d3d62c43d5f04b6a784a2197\n\n可以看到，格式完全变了\n所以千万不要在 windows 上面使用，不过也可能是我的机器问题\n从而导致的问题是，我的网站上面所有的文章全都使用新路径重新发布了一遍",
		"tags": [ "note"]
},

{
		"title": "docker-ubuntu-unminimize",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/docker-ubuntu-unminimize/",
		"content": "docker-ubuntu-unminimize\nunminimize 命令可以将 ubuntu 的环境切换成正常的环境，会安装很多软件进去\nhttps://wiki.ubuntu.com/Minimal\n\nThe 'unminimize' command will install the standard Ubuntu Server packages if you want to convert a Minimal instance to a standard Server environment for interactive use.\n\n但是这些软件里面没有 ping 、 traceroute 等网络实用工具",
		"tags": [ "note","linux"]
},

{
		"title": "epoll的边缘触发和水平触发",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/epoll的边缘触发和水平触发/",
		"content": "epoll的边缘触发和水平触发\nepoll 是 Linux 下用于处理大量文件描述符的高效 I/O 多路复用机制。在 epoll 中，有两种触发模式：水平触发（Level-Triggered，简称 LT）和边缘触发（Edge-Triggered，简称 ET）。\n\n水平触发（LT，Level-Triggered）：\n\n当文件描述符就绪时，epoll_wait 将立即返回。\n如果文件描述符的状态发生变化，epoll_wait 会再次通知应用程序。\n这种模式下，如果文件描述符有数据可读或可写，epoll_wait 将不停地返回通知，直到应用程序处理完数据或者阻塞。\n\n边缘触发（ET，Edge-Triggered）：\n\n当文件描述符就绪时，epoll_wait 只会通知一次，直到应用程序处理完数据并清空了文件描述符的缓冲区。\n如果文件描述符的状态没有变化，epoll_wait 不会重复通知应用程序。\n这种模式下，应用程序需要注意，在一个事件通知之后，要一直读或写，直到发生 EAGAIN 或 EWOULDBLOCK 错误。\n\n为什么epoll这里要叫做边缘触发和水平触发呢？\n这源于通信数字信号处理领域的术语，边缘和水平通常用于描述信号的特性\n\n边缘触发（Edge-Triggered）：\n\n&quot;边缘&quot; 指的是信号的变化边缘，即信号从一个状态变为另一个状态的瞬间。\n在数字信号处理中，边缘通常用来表示信号的上升沿或下降沿，即信号从低电平到高电平或从高电平到低电平的瞬间。\n\n水平触发（Level-Triggered）：\n\n&quot;水平&quot; 指的是信号的水平状态，即信号所处的电平状态。\n在数字信号处理中，水平触发通常用来描述信号保持在某个电平的状态，而不关心信号的变化瞬间。\n\nReference\nhttps://electronics.stackexchange.com/a/21891",
		"tags": [ "note"]
},

{
		"title": "202407251323  go flag 别在init中使用",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/go/202407251323  go flag 别在init中使用/",
		"content": "202407251323 go flag 别在init中使用\nflag.StringVar(&amp;appConfig, &quot;conf&quot;, filepath.Join(env.ConfDir(), &quot;app.toml&quot;), &quot;app config file&quot;)\nflag.Parse()\n\nflag 别在 init 中使用，否则在 go test 的时候会强制校验入参\n参考：\ngo test flag: flag provided but not defined\n\nflag.Parse() is being called before your flag is defined.\nYou have to make sure that all flag definitions happen before calling flag.Parse(), usually by defining all flags inside init() functions.",
		"tags": [ "note","Go"]
},

{
		"title": "go- make 和 new 关键字的区别",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/go/go- make 和 new 关键字的区别/",
		"content": "go- make 和 new 关键字的区别\n1 make 和 new 关键字的区别\n1.1 new\nGo语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化\n// The new built-in function allocates memory. The first argument is a type,\n// not a value, and the value returned is a pointer to a newly\n// allocated zero value of that type.\nfunc new(Type) *Type\n\nnew 关键字分配内存，返回指向此内存的指针，并且内存值为此类型的 零值\n这就是 new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。\n1.2 make\nmake 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。\nGo语言中的 new 和 make 主要区别如下：\n\nmake 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；\nnew 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；\nnew 分配的空间被清零。make 分配空间后，会进行初始化；",
		"tags": [ "note"]
},

{
		"title": "go-exec-run",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/go/go-exec-run/",
		"content": "go-exec-run\nRun 和 Wait 都是 os/exec 包中 Cmd 结构体的方法，用于执行外部命令，但它们在执行方式上有一些关键的区别。\nRun 方法\nRun 方法会启动外部命令，等待它完成，并返回一个错误值。如果命令成功执行（即退出状态为0），Run 返回 nil。如果命令执行失败（比如命令不存在，或者执行过程中出现了错误），则返回一个非 nil 的错误值。\nRun 是一个阻塞调用，意味着它会阻塞当前的 Goroutine 直到外部命令执行完成。它实际上是 Start 和 Wait 方法的组合。首先，Run 调用 Start 方法来启动命令，然后立即调用 Wait 方法等待命令执行结束。\ncmd := exec.Command(&quot;echo&quot;, &quot;Hello, World!&quot;)\nerr := cmd.Run()\nif err != nil {\nlog.Fatalf(&quot;cmd.Run() failed with %s\\n&quot;, err)\n}\n\nWait 方法\nWait 方法会阻塞调用它的 Goroutine，直到 Cmd 表示的命令执行完成。它必须在 Start 方法之后调用。Start 方法启动命令但不等待它结束，这使得你可以在命令执行的同时做一些其他的事情（比如读取命令的输出）。一旦你准备好等待命令执行完成，就可以调用 Wait 方法。\n如果命令成功执行，Wait 返回 nil。如果执行失败，则返回一个非 nil 的错误值。\n使用 Start 和 Wait 的组合，你可以更灵活地控制命令的执行过程。\ncmd := exec.Command(&quot;echo&quot;, &quot;Hello, World!&quot;)\nerr := cmd.Start()\nif err != nil {\nlog.Fatal(err)\n}\n\nerr = cmd.Wait()\nif err != nil {\nlog.Fatal(err)\n}\n\n区别总结\n\nRun 是一个便利的方法，用于当你只需要简单地执行一个命令并等待它完成时。它是 Start 和 Wait 的组合。\n使用 Start 和 Wait 可以让你在命令执行的同时做一些其他的处理，比如并发地处理命令的输出。这提供了更高的灵活性，但也需要你手动管理命令的启动和完成等待。\n\n选择使用哪一个方法取决于你的具体需求和你想要的控制级别。对于大多数简单的用例，Run 方法可能就足够了。但如果你需要更细粒度的控制，比如并发处理命令的输出，那么使用 Start 和 Wait 的组合可能更合适。\nReference",
		"tags": [ "note","Go"]
},

{
		"title": "go-exec",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/go/go-exec/",
		"content": "go-exec\n在Go语言中，exec 包提供了执行外部命令的功能。这个包是标准库的一部分，允许你从Go程序中运行外部的系统命令和程序。使用这个包，你可以执行Shell命令，处理命令的输入输出，以及访问命令的返回状态。\n下面是如何使用 exec 包执行Shell命令的一些基本步骤和示例。\n1. 导入exec包\n在你的Go文件中，首先需要导入os/exec包。\nimport &quot;os/exec&quot;\n\n2. 创建命令\n使用exec.Command函数创建一个新的*exec.Cmd对象，该对象用于执行外部命令。这个函数的第一个参数是命令名称，后续参数是命令需要的参数。\ncmd := exec.Command(&quot;echo&quot;, &quot;Hello, World!&quot;)\n\n如果你需要执行的命令需要Shell特性（比如管道、文件重定向等），你可以通过在Shell中执行命令来实现。例如，在Unix系统中，可以使用bash的-c选项。\ncmd := exec.Command(&quot;bash&quot;, &quot;-c&quot;, &quot;ls -l | grep .go&quot;)\n\n3. 运行命令\n有几种方法可以用来运行命令并获取输出。\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/go/go-exec-run/\">go-exec-run</a>\n\nRun：运行命令，并等待命令完成。\n\nerr := cmd.Run()\nif err != nil {\nlog.Fatalf(&quot;cmd.Run() failed with %s\\n&quot;, err)\n}\n\nOutput：运行命令，并收集命令的标准输出。\n\nout, err := cmd.Output()\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf(&quot;The output is %s\\n&quot;, out)\n\nCombinedOutput：运行命令，并收集标准输出和标准错误。\n\nout, err := cmd.CombinedOutput()\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf(&quot;The combined output is %s\\n&quot;, out)\n\nStart 和 Wait：Start 开始执行命令但不等待它完成，Wait 等待命令完成。\n\nerr := cmd.Start()\nif err != nil {\nlog.Fatal(err)\n}\n\nerr = cmd.Wait()\nif err != nil {\nlog.Fatal(err)\n}\n\n4. 处理命令的输入输出\n你可以通过设置Cmd结构体的Stdin、Stdout、Stderr属性来处理命令的输入输出。\ncmd.Stdin = strings.NewReader(&quot;some input&quot;)\nvar out bytes.Buffer\ncmd.Stdout = &amp;out\nerr := cmd.Run()\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf(&quot;The output is %s\\n&quot;, out.String())\n\n5. 获取命令的返回状态\n命令的返回状态可以通过检查Run、Output或CombinedOutput方法返回的错误来获取。如果命令以非零状态退出，这些方法会返回一个*exec.ExitError类型的错误。\nif exitErr, ok := err.(*exec.ExitError); ok {\n// 这里可以获取到非零退出状态和更多信息\nfmt.Printf(&quot;Command exited with status %d\\n&quot;, exitErr.ExitCode())\n}\n\n总结\n通过Go的exec包，你可以方便地执行外部命令和处理Shell命令。这对于需要与系统层面交互的程序来说非常有用。记得总是仔细处理命令的输出和错误，以及考虑安全性，避免执行不受信任的命令。\nReference",
		"tags": [ "note","Go"]
},

{
		"title": "go-mod",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/go/go-mod/",
		"content": "go-mod\nmodule novel-spider\n\ngo 1.16\n\nrequire (\ngithub.com/antchfx/xpath latest\n)\n\nreplace (\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a\n)\n\nmodule 当前包的名字\nrequire 指定依赖项， 跟 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">go-import</a> 很像\nreplace 无法自动获取的资源，可以使用 replace 来用本地资源替代\n参考： https://www.jianshu.com/p/760c97ff644c\ngo mod init [模块名]\ngo mod tidy",
		"tags": [ "note"]
},

{
		"title": "iso-日期表示法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/iso-日期表示法/",
		"content": "国际标准化组织的日期时间表示法\n日期时间点表示法\n零时区\n在最后加上大写 的 Z\n2004-05-03T17:30:08Z\n其他时区\n合并表示时，要在时间前面加一大写字母T，如要表示东八区时间2004年5月3日下午5点30分8秒，可以写成2004-05-03T17:30:08+08:00或20040503T173008+08。\n时间点表示法\n首字母为 P，其他字母为年月日时分秒，中间加上 T\nP1Y3M5DT6H7M30S\n时间间隔表示法\n从一个时间开始，到另一个时间结束\n19850412/19860101\n从指定时间开始持续一段时间\n19850412/P6M\n循环时间表示法\n\nR【循环次数】【/开始时间】/时间间隔【/结束时间】\n\n从2004年5月6日北京时间下午1点起时间间隔半年零5天3小时循环，且循环3次\nR3/20040506T130000+08/P0Y6M5DT3H0M0S。\n以1年2个月为循环间隔，无限次循环，最后循环终止于2025年1月1日\nR/P1Y2M/20250101\n参考",
		"tags": [ "note"]
},

{
		"title": "ithoughtx破产了",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/ithoughtx破产了/",
		"content": "ithoughtx破产了\nithoughtx 思维导图软件的公司 toketaWare 破产了。一个十几年的软件公司就这么没了，这个软件我觉得是非常好用的。\nhttps://www.toketaware.com/about",
		"tags": [ "note"]
},

{
		"title": "js超长数字溢出问题",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/js超长数字溢出问题/",
		"content": "tags: #js #联调 #踩坑\nhttps://www.cnblogs.com/wudanyang/p/15940613.html\n现象\n之前遇到过的一个问题\n接口要返回给前端（js）一个比较长的数字：759830849237899244\n看了接口返回是没问题的，但是前端拿着数字去取详情的时候，传过来的是另外一个数字：759830849237899300\n一比较，看起来是数字被转换了\n759830849237899244 =&gt; 759830849237899300\n在前端控制台执行一下：\n\n果然被转成了另外一个数字，而且看规律很像是后三位被上取整了\n原理\n后来了解到js会将数字按照下图方式切分后表示数字，以至于最高表示的数字只能到 9007199254740991 比这个数字更大的数字就会发生进位溢出\n\n解决方案\n解决方案很好办，那就是将数字转成字符串，只要前端不强转成数字，那就不会出问题\n\n参考文档\nJSON Bigint 大数精度丢失的背后\nJSON.parse parses / converts big numbers incorrectly",
		"tags": ["js", "联调", "踩坑", "note"]
},

{
		"title": "202404091044 leetcode-会员购买优惠-宫水三叶",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/202404091044 leetcode-会员购买优惠-宫水三叶/",
		"content": "202404091044 leetcode-会员购买优惠-宫水三叶\n宫水三叶的优惠链接，多 60 天： https://leetcode.cn/premium/?promoChannel=acoier\n\n年度会员 : 加赠 425−365=60 天\n季度会员 : 加赠 104−90=14 天\n\n同时，同时，同时！！！你还将获取如下福利：\n\n返佣红包：年度会员获得定额红包 ¥66.66（折算后 ¥1.02/天），季度会员获得定额红包 ¥22.22（折算后 ¥1.70/天）\n\n1 Reference\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">巨划算的 LeetCode 会员专属福利 ~ - 知乎</a>",
		"tags": [ "note"]
},

{
		"title": "202409112305 动态规划很多时候就是在填表",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/202409112305 动态规划很多时候就是在填表/",
		"content": "202409112305 动态规划很多时候就是在填表\nhttps://leetcode.cn/problems/longest-palindromic-substring/solutions/7792/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419\n填表的顺序是非常重要的",
		"tags": [ "note"]
},

{
		"title": "5. 最长回文子串",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/5. 最长回文子串/",
		"content": "5. 最长回文子串\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/leetcode/202409112305 动态规划很多时候就是在填表/\">202409112305 动态规划很多时候就是在填表</a>\n\n暴力解法\n动态规划\n马拉车算法，没仔细看\n\n动态规划算法：\nfunc longestPalindrome(s string) string {\nreturn dynamic(s)\n}\n\nfunc dynamic(s string) string {\n\ndp := make([][]bool, len(s))\n\nfor i := range dp {\ndp[i] = make([]bool, len(s))\ndp[i][i] = true\n}\n\nret := s[0:1]\nmxLen := 1\nfor j := 1; j &lt; len(s); j++ {\nfor i := 0; i&lt;j; i++ {\nif s[i] == s[j] {\nif j-i &lt; 3 {\ndp[i][j] = true\n} else {\ndp[i][j] = dp[i+1][j-1]\n}\nif dp[i][j] &amp;&amp; j-i+1 &gt; mxLen {\nmxLen = j-i+1\nret = s[i:j+1]\n}\n} else {\ndp[i][j] = false\n}\n}\n}\n\nreturn ret\n}\n\n初始化：\n填表格，对角线，也就是 i=j 时，单个字符，都是回文串，设置为 true dp[i][i] = true\n遍历顺序：\n因为初始化的是对角线，也就是如图所示：\n图中对角线坐标写错了，应该是 [0,0] [1,1] [2,2] [3,3]\n\n如果按照平常的顺序，这么写代码遍历\nfor i := 0; i &lt; len(s); i++ {\n\tfor j := i+1; j&lt;len(s); j++ {\n\t\t...\n\t}\n}\n\n那么会有如图所示的问题，[0,3] 会因为需要 [1,2] 的结果从而导致无法推算出正确的结果\n\n所以需要这么遍历，就能够使用到上一列的数据",
		"tags": [ "note","leetcode"]
},

{
		"title": "leetcode 编码技巧",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/leetcode 编码技巧/",
		"content": "leetcode 编码技巧\n编码技巧\n数字\n快速上取整\n正整数的情况下， a/b 上取整可以使用 :\n(a+b-1)/b 快速计算，适用于强类型语言\n取中间数\n强类型语言：(left+right)/2 。此方式在 left+right 时有可能会出现溢出，可以使用 left-(left-right)/2 计算\n整除\n123 &gt;&gt; 1 // 右移一位即可完成整除\n\n二进制\n最低位1变0\nnum1 &amp;= num1 - 1 // 最低的 1 变成 0\n\n最低位0变1\nnum1 |= num1 + 1 // 最低的 0 变成 1\n\n判断是否是2的整数次\nif (num &amp; (num - 1)) == 0 {\n\treturn true\n}\n\n0和1取反\nx ^= 1\n\nfunc flip(a int) int {\n\tif a == 0 {\n\t\treturn 1\n\t}\n\n\treturn 0\n}\n\nx = 1 - x\n\n数组\n双指针\n1. 两数之和 - 力扣（LeetCode）\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">leetcode-42. 接雨水</a>\n对向双指针 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">leetcode-11. 盛最多水的容器</a>\n前缀和\npre := []int{}\n\nfor i := range nums {\n\tif i == 0 {\n\t\tpre[i] = 0\n\t\tcontinue\n\t}\n\n\tpre[i] = pre[i-1] + nums[i-1]\n}\n\n从前缀和中获取后缀和\n// 小技巧，前缀和也能得出后缀和\nif i == 0 {\npostfixSum = prefixSum[len(prefixSum)-1]\n} else {\npostfixSum = prefixSum[len(prefixSum)-1] - prefixSum[i-1]\n}\n\n深度搜索\n方向\n在做深度搜索题时，经常用到方向，可以用下面的代码判断方向\nvar (\ndx = []int{1, 0, 0, -1}\ndy = []int{0, 1, -1, 0}\n)\n\n// 四个方向\nfor j := 0; j &lt; 4; j++ {\nmx, my := cell[0] + dx[j], cell[1] + dy[j]\n// 查看每个方向有没有超出边界，如果没有超出边界则进行处理\nif mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor {\nqueue = append(queue, []int{mx, my})\nimage[mx][my] = color\n}\n}\n\n字符串\n字符在数组中的偏移位置\nwidths[c-'a']\n\n矩阵\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">判断点在对角线上</a>\nReference",
		"tags": [ "note"]
},

{
		"title": "leetcode-1014. 最佳观光组合",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/leetcode-1014. 最佳观光组合/",
		"content": "#leetcode\nleetcode-1014. 最佳观光组合\n1014. 最佳观光组合\n解法\n转换一下公式\nvn 代表 i 与 j 的值\nfn 为最大值\n因为 values[j] - j 是固定的，所以，只需要求 values[i] + i 的最大值就可以了\nvn= values [i]+i+ values [j]−jfn=max( values [i]+i+ values [j]−jclass Solution {\n\n/**\n* @param Integer[] $values\n* @return Integer\n*/\nfunction maxScoreSightseeingPair($values) {\n$len = count($values);\n$max = $maxI = 0;\nfor ($i = 0; $i &lt; $len; $i++) {\n$max = max($max, $maxI + $values[$i] - $i);\n$maxI = max($values[$i], $maxI);\n}\n\nreturn $max;\n}\n}\n\n参考\n官方题解",
		"tags": ["leetcode", "note"]
},

{
		"title": "leetcode-1137第 N 个泰波那契数",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/leetcode-1137第 N 个泰波那契数/",
		"content": "leetcode-1137第 N 个泰波那契数\n1137. 第 N 个泰波那契数\n这个跟斐波那契好像是一样的，一模一样\n解法\n跟斐波纳契数列一样的解法\nclass Solution {\n\n/**\n* @param Integer $n\n* @return Integer\n*/\nfunction tribonacci($n) {\nif ($n &lt;= 0) {\nreturn 0;\n}\n\n$retArr = [0,1,1];\nfor ($i = 3; $i &lt;= $n; $i++) {\n$retArr[$i] = $retArr[$i-1] + $retArr[$i-2] + $retArr[$i-3];\n}\n\nreturn $retArr[$n];\n}\n}\n\n参考",
		"tags": [ "note","leetcode"]
},

{
		"title": "leetcode-53. 最大子数组和",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/leetcode/leetcode-53. 最大子数组和/",
		"content": "leetcode-53. 最大子数组和\n53. 最大子数组和\n解法\n\n第一版写的时候，可以加一个 dp 数组，保存每个节点的最大值\n\ndp 公式\nfn={max(nums[n]+fn−1,nums[n])n&gt;=1nums[n],n=0class Solution {\n\n/**\n* @param Integer[] $nums\n* @return Integer\n*/\nfunction maxSubArray($nums) {\n$len = count($nums);\nif ($len == 1) {\nreturn $nums[0];\n}\n\n$currentMaxSum = $nums[0];\n\n$max = $nums[0];\nfor ($i=1; $i &lt; $len; $i++) {\n$currentMaxSum = max($currentMaxSum + $nums[$i], $nums[$i]);\n$max = max($currentMaxSum, $max);\n}\n\nreturn $max;\n}\n}",
		"tags": [ "note","dp"]
},

{
		"title": "linux-echo",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/linux-echo/",
		"content": "linux-echo\necho &quot;hello&quot;\necho -n &quot;hello&quot; # 这种会去掉换行\nsh 不支持这个 -n 参数，很奇怪\n使用 -n 参数 zsh 后面会跟着一个百分号\n\nPrintf puts a percent sign after everything it prints\n\nThis is zsh's way of telling you that the preceding command outputted a partial line and the shell terminated that line to give you a prompt on a new line.",
		"tags": [ "note","linux"]
},

{
		"title": "linux-man命令使用",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/linux-man命令使用/",
		"content": "linux-man命令使用\n1 - commands（普通的命令）\n2 - system calls（系统调用）\n3 - library calls（库函数）\n4 - special files（特殊文件：/dev下设备文件）\n5 - file formats and convertions（文件格式）\n6 - games for linux（游戏和娱乐）\n7 - macro packages and conventions（杂项）\n8 - system management commands（管理员命令）\n9 - 其他（Linux特定， 用来存放内核例行程序的文档）\n可使用 man man 进入此页面\n参考\nhttps://blog.csdn.net/zhang_chou_chou/article/details/83589224\n在线 man 手册",
		"tags": [ "note","linux"]
},

{
		"title": "linux-pidstat",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/linux-pidstat/",
		"content": "linux-pidstat\n$pidstat 1 5 11:46\nLinux 5.4.0-1034-raspi (wdy-ubuntu) \t05/20/21 \t_aarch64_\t(4 CPU)\n\n11:46:13 UID PID %usr %system %guest %wait %CPU CPU Command\n11:46:14 0 1871 0.00 0.97 0.00 0.00 0.97 3 phtunnel\n11:46:14 1000 4506 0.97 0.00 0.00 0.00 0.97 0 gsd-xsettings\n11:46:14 1000 115573 0.97 2.91 0.00 0.00 3.88 1 pidstat\n\n11:46:14 UID PID %usr %system %guest %wait %CPU CPU Command\n11:46:15 1000 115573 0.00 4.00 0.00 0.00 4.00 1 pidstat\n\n11:46:15 UID PID %usr %system %guest %wait %CPU CPU Command\n11:46:16 1000 4747 1.00 0.00 0.00 0.00 1.00 2 gnome-software\n11:46:16 0 115462 0.00 1.00 0.00 0.00 1.00 2 kworker/2:1-events\n11:46:16 1000 115573 1.00 3.00 0.00 0.00 4.00 1 pidstat\n\n11:46:16 UID PID %usr %system %guest %wait %CPU CPU Command\n11:46:17 0 93708 0.00 1.00 0.00 0.00 1.00 2 containerd\n11:46:17 1000 115573 1.00 3.00 0.00 0.00 4.00 1 pidstat\n\n11:46:17 UID PID %usr %system %guest %wait %CPU CPU Command\n11:46:18 1000 115573 1.00 2.00 0.00 0.00 3.00 1 pidstat\n\nAverage: UID PID %usr %system %guest %wait %CPU CPU Command\nAverage: 0 1871 0.00 0.20 0.00 0.00 0.20 - phtunnel\nAverage: 1000 4506 0.20 0.00 0.00 0.00 0.20 - gsd-xsettings\nAverage: 1000 4747 0.20 0.00 0.00 0.00 0.20 - gnome-software\nAverage: 0 93708 0.00 0.20 0.00 0.00 0.20 - containerd\nAverage: 0 115462 0.00 0.20 0.00 0.00 0.20 - kworker/2:1-events\nAverage: 1000 115573 0.80 2.98 0.00 0.00 3.78 - pidstat\n\npidstat 是 sysstat 工具包的一部分，可以用来监控特定进程的 CPU、内存、I/O 等使用情况。与其他命令不同，pidstat 提供了针对单个进程级别的统计信息，非常适合分析某个进程的性能表现。\n1 安装 pidstat\npidstat 属于 sysstat 工具包。如果尚未安装，可以使用以下命令进行安装：\nsudo apt-get install sysstat # 对于 Debian/Ubuntu\nsudo yum install sysstat # 对于 CentOS/RHEL\n\n2 使用 pidstat 查看 CPU 使用情况\n要查看所有进程的 CPU 使用情况，可以使用：\npidstat 1\n\n其中，1 表示每秒刷新一次 CPU 使用情况。输出示例：\nLinux 4.15.0-20-generic (hostname) 09/19/2024 _x86_64_ (4 CPU)\n\n09:26:35 PID %usr %system %guest %CPU CPU Command\n09:26:36 1023 0.00 0.50 0.00 0.50 1 apache2\n09:26:36 1234 0.20 0.30 0.00 0.50 0 chrome\n\n输出中的各列解释：\n\n%usr：用户态 CPU 使用率。\n%system：系统态 CPU 使用率。\n%CPU：总 CPU 使用率。\nPID：进程 ID。\nCommand：进程名称。\n\n3 查看特定进程的 CPU 使用情况\n如果想监控某个特定进程，比如 PID 为 1234 的进程，可以使用：\npidstat -p 1234 1\n\n4 查看线程级别的 CPU 使用情况\n要查看进程中的每个线程的 CPU 使用情况，可以使用 -t 参数：\npidstat -t 1\n\n这样可以分析多线程程序的性能表现。\n5 查看内存和 I/O 使用情况\npidstat 还可以查看进程的内存和 I/O 使用情况：\n\n查看内存使用情况：\n\npidstat -r 1\n\n查看 I/O 使用情况：\n\npidstat -d 1\n\npidstat 是一个强大的工具，适合监控和分析单个进程的资源使用情况。\n参考\nhttps://time.geekbang.org/column/article/70476",
		"tags": [ "note"]
},

{
		"title": "linux-wait",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/linux-wait/",
		"content": "Content\nfor pid in $(jobs -p); do\nwait $pid\nstatus=$?\nif [ $status != 0 ]; then\necho &quot; $pid status is $status have some error!&quot; &gt;&gt; your_log\nelse\necho &quot;$pid status is $status success!&quot; &gt;&gt; your_log\nfi\ndone\n\nReference\nwait(1p) - Linux manual page",
		"tags": [ "note","linux"]
},

{
		"title": "linux-查看内存占用情况",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/linux-查看内存占用情况/",
		"content": "linux-查看内存占用情况\nps --no-headers -o &quot;rss,cmd&quot; -A | awk '{print $1/1024&quot;M&quot;,&quot;\\t&quot;,$0}' | sort -n -k1",
		"tags": [ "note"]
},

{
		"title": "linux-树莓派无法上网排查",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/linux-树莓派无法上网排查/",
		"content": "linux-树莓派无法上网排查\n\nwget -v baidu.com\n\n会有输出：\n如何处理呢\n\n--2021-07-15 10:52:24-- http://baidu.com/\nResolving baidu.com (baidu.com)... 39.156.69.79, 220.181.38.148\nConnecting to baidu.com (baidu.com)|39.156.69.79|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 81 [text/html]\nSaving to: ‘index.html’\n\n上次我就卡在了 解析 baidu.com 域名这个地方\n\n通过 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">linux-nslookup</a> 命令查看路由解析\n\n发现解析不通\n查看 /etc/resolv.conf 将 nameserver 改成： 114.114.114.114\n再次查看路由解析，发现已经 OK 了\n\n如何修改 /etc/resolv.conf ，重启机器之后会发现文件又被改回去了，导致无法联网，正确的做法\n\nsudo vi /etc/systemd/resolved.conf\n重启网络服务 sudo service networking restart\n\n树莓派4B】三、笔记本给树莓派Ubuntu 18.04提供网络|为什么Ubuntu18.04更改/etc/resolv.conf修改nameserver重启网络被重置",
		"tags": [ "note","树莓派"]
},

{
		"title": "mac 运行 kafka",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/mac 运行 kafka/",
		"content": "mac 运行 kafka\n安装\nbrew install kafka\n\n启动 broker\n手动启动 kafka， 同时启动一个使用 2181 端口的 zookeeper\n/opt/homebrew/opt/kafka/bin/zookeeper-server-start /opt/homebrew/etc/kafka/zookeeper.properties\n/opt/homebrew/opt/kafka/bin/kafka-server-start /opt/homebrew/etc/kafka/server.properties\n\n启动生产者\n/opt/homebrew/opt/kafka/bin/kafka-console-producer --topic test --bootstrap-server localhost:9092\n\n启动消费者\n/opt/homebrew/opt/kafka/bin/kafka-console-consumer --topic test --bootstrap-server localhost:9092 --from-beginning\n\n创建 topic\nkafka-topics --create --replication-factor 1 --partitions 5 --topic myTopic --bootstrap-server localhost:9092\n\n查看 topic 列表\n/opt/homebrew/opt/kafka/bin/kafka-topics --bootstrap-server localhost:9092 --list\n\n数据文件目录\n/opt/homebrew/var/lib/kafka-logs/\n\n简易 go 程序\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;github.com/confluentinc/confluent-kafka-go/v2/kafka&quot;\n)\n\nfunc main() {\n\n\tp, err := kafka.NewProducer(&amp;kafka.ConfigMap{&quot;bootstrap.servers&quot;: &quot;localhost&quot;})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer p.Close()\n\n\t// Delivery report handler for produced messages\n\tgo func() {\n\t\tfor e := range p.Events() {\n\t\t\tswitch ev := e.(type) {\n\t\t\tcase *kafka.Message:\n\t\t\t\tif ev.TopicPartition.Error != nil {\n\t\t\t\t\tfmt.Printf(&quot;Delivery failed: %v\\n&quot;, ev.TopicPartition)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(&quot;Delivered message to %v\\n&quot;, ev.TopicPartition)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Produce messages to topic (asynchronously)\n\ttopic := &quot;myTopic&quot;\n\tfor _, word := range []string{&quot;Welcome&quot;, &quot;to&quot;, &quot;the&quot;, &quot;Confluent&quot;, &quot;Kafka&quot;, &quot;Golang&quot;, &quot;client&quot;} {\n\t\tp.Produce(&amp;kafka.Message{\n\t\t\tTopicPartition: kafka.TopicPartition{Topic: &amp;topic, Partition: kafka.PartitionAny},\n\t\t\tValue: []byte(word),\n\t\t}, nil)\n\t}\n\n\t// Wait for message deliveries before shutting down\n\tp.Flush(15 * 1000)\n}\n\n《Kafka 权威指南》章节列表\n《kafka 权威指南》\n章节列表：\n第 1 章 初识 kafka\n第 2 章 安装 Kafka\n第 3 章 Kafka 生产者——向 Kafka 写入数据\n第 4 章 Kafka 消费者——从 Kafka 读取数据\n第 5 章 深入 Kafka\n第 6 章 可靠的数据传递\n第 7 章 构建数据管道\n第 8 章 跨集群数据镜像\n第 9 章 管理 Kafka\n第 10 章 监控 Kafka\n第 11 章 流式处理\nReference\nmac环境下使用brew安装Kafka(详细过程)_brew kafka-CSDN博客\nKafka整体架构、工作流程与文件存储机制 - 细雨骑驴入剑门 - 博客园\n扫盲Kafka？看这一篇就够了！ - 京东云技术团队 - 博客园\nKafka元数据缓存(metadata cache) - huxihx - 博客园",
		"tags": [ "note","kafka","学习"]
},

{
		"title": "mpstat命令输出",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/mpstat命令输出/",
		"content": "mpstat命令输出\nLinux 6.8.0-44-generic (dy-turbo-vm) \t09/19/2024 \t_aarch64_\t(8 CPU)\n\n10:52:27 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle\n10:52:27 AM all 0.02 0.00 0.05 0.01 0.00 0.00 0.00 0.00 0.00 99.91",
		"tags": [ "note"]
},

{
		"title": "mysql5.7json支持",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/mysql5.7json支持/",
		"content": "mysql5.7json支持\n内容\n原生支持 json\ncreate table user ( uid int auto_increment, data json,primary key(uid)) engine=innodb;\n\n可以选择使用 json 类型来创建列\n虚拟列，可以创建索引\n-- 先创建一个虚拟列\nalter table user add user_name varchar(128) generated always as (json_extract(data,'$.name')) virtual;\n\n-- 然后在虚拟列上创建索引\nalter table user add index idx_username (user_name);\n\n这里存疑一点，虚拟列的维护可能会耗费比较多的资源，会导致插入性能降低\n虽然虚拟列的值在实际查询时动态计算，节省了磁盘存储空间，但这种计算确实可能在一定程度上影响插入和更新性能。每次插入或更新记录时，MySQL 都需要计算或重新计算虚拟列的值。\n如果在虚拟列上建立索引，这种效果可能会更加显著，因为每次插入或更新操作还需要更新索引。此外，创建索引本身也会消耗磁盘空间。\n然而，这些影响因情况而异。虚拟列表达式的计算性能，以及查询虚拟列和索引所带来的性能提升，可能会抵消甚至超过额外的插入和更新成本。特别是在对存储空间有严格要求，或者需要频繁查询 JSON 属性的场景中，使用虚拟列和索引可能是一个好的选择。\n总的来说，是否使用虚拟列和在其上建立索引，需要根据实际的数据特性、查询模式和性能要求综合考虑决定。在实际应用中，可能需要进行一些性能测试和调优来找到最适合的解决方案。\n参考\nMySQL 5.7原生JSON格式支持 - 腾讯云开发者社区-腾讯云\nMySQL :: MySQL 5.7 Reference Manual :: 11.5 The JSON Data Type",
		"tags": [ "note","mysql"]
},

{
		"title": "Nginx Master 进程主流程",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/nginx master 进程/",
		"content": "nginx master 进程\n之前有说到 nginx 进程模型-整体架构，下面来看一下 nginx master 进程的主要工作\nnginx 的入口 main 函数在 nginx.c 文件中\n函数原型为：\nint ngx_cdecl\nmain(int argc, char *const *argv)\n\n在这个函数中，master 做了一系列的初始化操作\n最终在下面这个地方进入了主流程中：\n//...\nif (ngx_process == NGX_PROCESS_SINGLE) {\nngx_single_process_cycle(cycle);\n\n} else {\nngx_master_process_cycle(cycle);\n}\n//...\n\n因为我们主要看 master-worker 这种进程模型，所以进入 ngx_master_process_cycle\n设置信号屏蔽字，防止创建子进程过程中被信号中断\n// 先清空信号集\nsigemptyset(&amp;set);\nsigaddset(&amp;set, SIGCHLD);\nsigaddset(&amp;set, SIGALRM);\nsigaddset(&amp;set, SIGIO);\nsigaddset(&amp;set, SIGINT);\nsigaddset(&amp;set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));\nsigaddset(&amp;set, ngx_signal_value(NGX_REOPEN_SIGNAL));\nsigaddset(&amp;set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));\nsigaddset(&amp;set, ngx_signal_value(NGX_TERMINATE_SIGNAL));\nsigaddset(&amp;set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\nsigaddset(&amp;set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));\n\n// 设置信号屏蔽字，将 set 中的信号设置为阻塞状态，防止创建worker 的过程中，被进来的信号打断\nif (sigprocmask(SIG_BLOCK, &amp;set, NULL) == -1) {\nngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,\n&quot;sigprocmask() failed&quot;);\n}\n\n// 将 set 清空\nsigemptyset(&amp;set);\n\n设置信号屏蔽字，防止在创建子进程的过程中被信号处理程序中断\n关于信号屏蔽字，引用 《UNIX 环境高级编程》 中信号一节的部分内容：\n\n进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作或捕捉该信号, 则为该进程将此信号保持为未决状态,直到该进程对此信号解除了阻塞, 或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时),才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用 sigpending 函数(见10.13节)来判定哪些信号是设置为阻塞并处于未决状态的。\n\n每个进程都有一个信号屏蔽字( signal mask),它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号,该屏蔽字中都有一位与之对应。对于某种信号,若其对应位已设置,则它当前是被阻塞的。进程可以调用 sigprocmask(在10.12节中说明)来检测和更改其当前信号屏蔽字。\n\n当然，在下面创建完子进程之后，会使用 sigsuspend 解除信号屏蔽，并使 master 进程进入休眠\n关于 sigsuspend 函数，简单来说，它是一个 sigprocmask(SIG_SETMASK, &amp;emptyset, NULL) 和 pause() 函数的结合体，不过相对于使用两个函数完成上述操作，sigsuspend 是 原子操作。\n具体的操作如下：\n\n使用新的信号集合设置屏蔽字，在这里是清空屏蔽字\n调用信号处理函数，并从信号处理程序返回\n屏蔽字恢复成调用 sigsuspend 之前的值（再次不让进程被信号打断）\n\n设置 master 进程的 title\nstatic u_char master_process[] = &quot;master process&quot;;\n\nsize = sizeof(master_process);\n\nfor (i = 0; i &lt; ngx_argc; i++) {\nsize += ngx_strlen(ngx_argv[i]) + 1;\n}\n\ntitle = ngx_pnalloc(cycle-&gt;pool, size);\nif (title == NULL) {\n/* fatal */\nexit(2);\n}\n\np = ngx_cpymem(title, master_process, sizeof(master_process) - 1);\nfor (i = 0; i &lt; ngx_argc; i++) {\n*p++ = ' ';\np = ngx_cpystrn(p, (u_char *) ngx_argv[i], size);\n}\n\nngx_setproctitle(title);\n\n将进程title设置成三个部分：\n\n固定字符：nginx:\n主进程标志: master process\n命令行启动的命令，如：/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\n\n所以进程刚开始是这样显示的：\n$ ps aux | grep nginx | grep -v grep\nroot 183117 0.0 0.0 4324 2680 ? ts 17:07 0:00 /home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\n\n设置了 title 之后，变成了下面这样：\n$ ps aux | grep nginx | grep -v grep\nroot 183117 0.0 0.0 4324 2680 ? ts 17:07 0:00 nginx: master process /home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\n\n根据配置启动相应数量的 worker 和 cache 管理进程\nccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);\n\nngx_start_worker_processes(cycle, ccf-&gt;worker_processes,\nNGX_PROCESS_RESPAWN);\nngx_start_cache_manager_processes(cycle, 0);\n\n监听信号，并作出响应\n在 ngx_init_signals 函数中，对原始信号做了变量名映射，具体映射如下：\n\n信号\n对应进程中的标志位变量\n含义\n\nQUIT\nngx_quit\n优雅关闭服务\n\nTERM 或 INT\nngx_terminate\n强制关闭服务\n\nUSR1\nngx_reopen\n重新打开服务中的所有文件\n\nWINCH\nngx_noaccept\n所有子进程不再接受处理新的连接，实际相当于对所有的子进程发送 QUIT 信号\n\nUSR2\nngx_change_binary\n平滑升级到新版本的 Nginx 程序\n\nHUP\nngx_reconfigure\n重新读取配置文件并使服务对新配置项生效\n\nCHLD\nngx_reap\n有子进程意外结束master 会监控所有子进程，并在子进程意外退出时调用 ngx_reap_children 方法重启子进程\n\nmaster 并不是时刻不停的执行循环检测这些标志位，而是通过 sigsuspend 进入休眠，等待有信号唤醒进程时，再循环检测所有信号并处理。\n参考\nnginx中的ngx_cdecl\nNginx源码|Nginx信号处理\nnginx 信号处理\nLINUX C中sigprocmask()函数用法\nlinux信号的阻塞和未决\n《UNIX 环境高级编程》\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/nginx-master-start-worker/\">nginx-master-start-worker</a>",
		"tags": [ "note","nginx","master","Process","source-code"]
},

{
		"title": "Nginx 进程模型-整体架构",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/nginx 进程模型-整体架构/",
		"content": "nginx 进程模型 - 整体架构\n\n从网上找了一个非常好的图片，从图中可以看到很多东西\n\nNginx 会生成多个进程\nworker 使用了 io 多路复用的事件驱动框架\nworker 内部有很多模块\nworker 处理磁盘 I/O 时，使用了标准 I/O ， sendfile ， AIO ，mmap 等 I/O 技术\nCache loader 和 Cache manager 操作 proxy cache\n后端支持多种基于 tcp 的网络协议",
		"tags": [ "note","nginx"]
},

{
		"title": "Nginx Master 启动 worker 进程的流程",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/nginx-master-start-worker/",
		"content": "nginx-master-start-worker\n入口\n启动子进程的流程在ngx_start_worker_processes函数中，具体代码如下：\nstatic void\nngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)\n{\nngx_int_t i;\n\nngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, 0, &quot;start worker processes&quot;);\n\nfor (i = 0; i &lt; n; i++) {\n\nngx_spawn_process(cycle, ngx_worker_process_cycle,\n(void *) (intptr_t) i, &quot;worker process&quot;, type);\n\nngx_pass_open_channel(cycle);\n}\n}\n\n创建子进程\n其中创建子进程的函数为 ngx_spawn_process，主要就是封装了 fork 函数。\nngx_pid_t\nngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,\nchar *name, ngx_int_t respawn)\n{\n// ...\npid = fork();\n\nswitch (pid) {\n\ncase -1:\nngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,\n&quot;fork() failed while spawning \\&quot;%s\\&quot;&quot;, name);\nngx_close_channel(ngx_processes[s].channel, cycle-&gt;log);\nreturn NGX_INVALID_PID;\n\ncase 0:\nngx_parent = ngx_pid;\nngx_pid = ngx_getpid();\nproc(cycle, data);\nbreak;\n\ndefault:\nbreak;\n}\n\nngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, 0, &quot;start %s %P&quot;, name, pid);\n\nngx_processes[s].pid = pid;\nngx_processes[s].exited = 0;\n\n// ...\n}\n\nfork 函数的返回值：\n\n子进程返回0，父进程返回子进程id，若出错，返回 -1\n\n子进程在 case 0 中执行 proc 函数，proc 函数是 ngx_start_worker_processes 函数中传进来的第二个参数 ngx_worker_process_cycle。\nngx_worker_process_cycle 函数，就是 worker 进程的主要流程，以后会继续分析。\n最大子进程数量\nif (s == NGX_MAX_PROCESSES) {\nngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, 0,\n&quot;no more than %d processes can be spawned&quot;,\nNGX_MAX_PROCESSES);\nreturn NGX_INVALID_PID;\n}\n\n#define NGX_MAX_PROCESSES 1024\n\n最大子进程数量定义成了 NGX_MAX_PROCESSES 也就是 1024，如果超过了 1024个进程，就会报错\nrespawn 参数的意义\nrespawn 大于等于0时\nrespawn 大于等于0时，代表重启子进程，respawn 代表给 ngx_processes 数组的下标\nif (respawn &gt;= 0) {\ns = respawn;\n} else {\n...\n}\n\nrespawn 小于0时\nrespawn 小于0时，代表启动的子进程的属性，子进程的几种属性：\n#define NGX_PROCESS_NORESPAWN -1\n#define NGX_PROCESS_JUST_SPAWN -2\n#define NGX_PROCESS_RESPAWN -3\n#define NGX_PROCESS_JUST_RESPAWN -4\n#define NGX_PROCESS_DETACHED -5\n\n那么 respawn 小于0时，子进程在 ngx_processes数组中的下标是多少呢？\n看下面这段代码：\nfor (s = 0; s &lt; ngx_last_process; s++) {\nif (ngx_processes[s].pid == -1) {\nbreak;\n}\n}\n\nif (s == NGX_MAX_PROCESSES) {\nngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, 0,\n&quot;no more than %d processes can be spawned&quot;,\nNGX_MAX_PROCESSES);\nreturn NGX_INVALID_PID;\n}\n\n实际上就是在找 ngx_processes 数组中未使用的最小下标。\n参考\n《UNIX 环境高级编程》\nos/unix/ngx_process.c源代码分析",
		"tags": ["define", "define", "define", "define", "define", "define", "note","nginx","Process","source-code"]
},

{
		"title": "202404181228 使用 open --background 的形式打开 obsidian 不够轻便",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/obsidian/202404181228 使用 open --background 的形式打开 obsidian 不够轻便/",
		"content": "202404181228 使用 open --background 的形式打开 obsidian 不够轻便\nmac 的快捷指令执行太慢，所以 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/工具/obsidian/不打开obsidian的情况下记录当前事件/\">不打开obsidian的情况下记录当前事件</a> 虽然能够实现后台记录日志，但是对流程太过打扰，所以我现在使用了 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Raycast</a> 的 floating note 进行简单记录一些一闪而过的想法，或者使用 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Things</a> 的快速捕获功能进行记录",
		"tags": [ "note"]
},

{
		"title": "202404181240 快捷指令-记录今天的事情 obsidian",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/obsidian/202404181240 快捷指令-记录今天的事情 obsidian/",
		"content": "202404181240 快捷指令-记录今天的事情 obsidian\n快捷指令地址： https://www.icloud.com/shortcuts/6f0552b8622c4b3389b0f53a7af1e919\n安装快捷指令\n修改快捷指令中的参数\n\n最终效果：\n\nobsidian 不会到前台占用你的注意力 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/工具/obsidian/不打开obsidian的情况下记录当前事件/\">不打开obsidian的情况下记录当前事件</a>",
		"tags": [ "note"]
},

{
		"title": "202409052343 github 部署任务设置 reviewer",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/obsidian/202409052343 github 部署任务设置 reviewer/",
		"content": "202409052343 github 部署任务设置 reviewer\n之前用 windows 机器部署的时候出了问题，大概率是 digital 插件兼容问题：<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/digital-garden 在 windows 上面 diff 出错/\">digital-garden 在 windows 上面 diff 出错</a>\n所以在站点部署时，增加了一个 review 环节，防止站点陷入瘫痪状态",
		"tags": [ "note"]
},

{
		"title": "php-xml 如何解析 cdata",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/php-xml 如何解析 cdata/",
		"content": "php-xml 如何解析 cdata\n$content = simplexml_load_string(\n'&lt;content&gt;&lt;![CDATA[Hello, world!]]&gt;&lt;/content&gt;'\n, null\n, LIBXML_NOCDATA // merge cdata as text node\n);\n\nhttps://stackoverflow.com/questions/2970602/php-how-to-handle-cdata-with-simplexmlelement",
		"tags": [ "note"]
},

{
		"title": "202012081017 - php8.0 新特性",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/php/202012081017 - php8.0 新特性/",
		"content": "202012081017 - php8.0 新特性\n\n把 youtube 中的 php8.0 的新特性看完了\n\ndoc 属性\njit\n?-&gt; null 安全运算符\nWeakMap\nstring 的函数 str_contain\n命名参数\n构造函数成员提升\nmatch 表达式匹配\nmixed 类型\n使用对象进行 ::class 调用\n联合类型 float|int",
		"tags": [ "note","php"]
},

{
		"title": "rdb 文件分析",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/rdb 文件分析/",
		"content": "<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/redis/202011281031 - 安装 rdbtools 工具/\">202011281031 - 安装 rdbtools 工具</a>\nrdb 文件分析\n命令行工具使用，先看 --help\nusage: usage: rdb [options] /path/to/dump.rdb\n\nExample : rdb --command json -k &quot;user.*&quot; /var/redis/6379/dump.rdb\n\npositional arguments:\ndump_file RDB Dump file to process\n\noptional arguments:\n-h, --help show this help message and exit\n-c CMD, --command CMD\nCommand to execute. Valid commands are json, diff,\njustkeys, justkeyvals, memory and protocol\n-f FILE, --file FILE Output file\n-n DBS, --db DBS Database Number. Multiple databases can be provided.\nIf not specified, all databases will be included.\n-k KEYS, --key KEYS Keys to export. This can be a regular expression\n-o NOT_KEYS, --not-key NOT_KEYS\nKeys Not to export. This can be a regular expression\n-t TYPES, --type TYPES\nData types to include. Possible values are string,\nhash, set, sortedset, list. Multiple typees can be\nprovided. If not specified, all data types will be\nreturned\n-b BYTES, --bytes BYTES\nLimit memory output to keys greater to or equal to\nthis value (in bytes)\n-l LARGEST, --largest LARGEST\nLimit memory output to only the top N keys (by size)\n-e {raw,print,utf8,base64}, --escape {raw,print,utf8,base64}\nEscape strings to encoding: raw (default), print,\nutf8, or base64.\n-x, --no-expire With protocol command, remove expiry from all keys\n-a N, --amend-expire N\nWith protocol command, add N seconds to key expiry\ntime\n\n参数解析\n\n-c 执行命令 输出不同格式的数据\n\njson; 输出 json 格式的字符串 如： [{&quot;int&quot;:&quot;1&quot;}]\ndiff; 导出可供 diff 、kdiff 、 vimdiff 比较的数据\njustkeys; 只输出 key\njustkeyvals; 只输出键值对，以空格分隔\nmemory; 输出内存分布状态\nprotocol; 输出原始的 RESP 协议\n\n-f 指定输出到文件\n-n 指定输出的 db\n-k 指定输出哪些 key; 可以使用正则表达式， 如： '^users_\\d+$'\n-o 排除哪些 key; 可以使用正则表达式\n-t 指定输出 value 的类型\n-b 指定大于此字节数的 key 输出\n-l 输出最大的多少个 key\n-e 转义字符串到其他格式\n\nraw 原始字符串\nprint\nutf8 输出原始 utf8 格式字符串\nbase64 对于二进制数据来说，可以先 base64 存储到文件，然后在程序中 decode 出来\n\n-x 在导出 RESP 协议内容时，去掉过期时间\n-a 导出 RESP 协议内容时，给有过期时间的 key 加上几秒钟过期时间\n\n下面看一下一些常见用法：\n生成内存报告\nrdb --command memory dump.rdb &gt; memory.csv\n\n生成 CSV 格式的内存报告。包含的列有：\n数据库 ID，数据类型，key，内存使用量 (byte)，编码。内存使用量包含 key、value 和其他值，结果：\ndatabase,type,key,size_in_bytes,encoding,num_elements,len_largest_element,expiry\n0,set,fruit,252,hashtable,2,6,\n0,hash,webset,81,ziplist,1,13,\n0,string,baiduyun,64,string,5,5,\n0,list,languages,161,quicklist,2,6,\n0,sortedset,page_rank,80,ziplist,1,9\n\n使用参数过滤想要的数据\n# 使用这个命令会将存储的 int 值显示为 json 的字符串\n&gt; rdb -c json --db 2 --type hash --key &quot;a.*&quot; /var/redis/6379/dump.rdb\n\n[{},{\n&quot;aroma&quot;:{&quot;pungent&quot;:&quot;vinegar&quot;,&quot;putrid&quot;:&quot;rotten eggs&quot;,&quot;floral&quot;:&quot;roses&quot;}}]\n\n比较两个 rdb 文件\n&gt; rdb --command diff /var/redis/6379/dump1.rdb | sort &gt; dump1.txt\n&gt; rdb --command diff /var/redis/6379/dump2.rdb | sort &gt; dump2.txt\n\n# 使用 diff 软件查看 diff\n&gt; kdiff3 dump1.txt dump2.txt\n\n查看一个 key 的内存使用情况\n&gt; redis-memory-for-key person:1\n\n&gt; redis-memory-for-key -s localhost -p 6379 -a mypassword person:1\n\nKey \t\t\tperson:1\nBytes\t\t\t\t111\nType\t\t\t\thash\nEncoding\t\t\tziplist\nNumber of Elements\t\t2\nLength of Largest Element\t8 # hash 中占用内存最大的那个 value 的占用字节数\n\n常见问题 FAQ\n\n内存报告的精确度如何？\n答：最多有 10% 的误差\n\n存储了一个二进制 binary 数据，但是输出的时候是乱码，不可读，怎么处理？\n答：可以使用 -e 命令先输出 base64 编码的字符串，然后程序中解码之后使用\n\n这个工具能解析哪个版本的 rdb 文件？\n答：2~6 版本\n\n我不想用 python，有其他的解析方案吗？\n答：\n\nredis-rdb is written in Ruby\nrdbhs is written in Haskell\nrdb-parser is written in Node.js\nrdb is written in Go\nrdb-rs is written in Rust\n参阅 rdb 文件格式 自己写一个解析\n\n参考\nhttps://github.com/sripathikrishnan/redis-rdb-tools",
		"tags": [ "note"]
},

{
		"title": "redis-rdb 文件分析",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/redis-rdb 文件分析/",
		"content": "<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/redis/202011281031 - 安装 rdbtools 工具/\">202011281031 - 安装 rdbtools 工具</a>\nredis-rdb 文件分析\n命令行工具使用，先看 --help\nusage: usage: rdb [options] /path/to/dump.rdb\n\nExample : rdb --command json -k &quot;user.*&quot; /var/redis/6379/dump.rdb\n\npositional arguments:\ndump_file RDB Dump file to process\n\noptional arguments:\n-h, --help show this help message and exit\n-c CMD, --command CMD\nCommand to execute. Valid commands are json, diff,\njustkeys, justkeyvals, memory and protocol\n-f FILE, --file FILE Output file\n-n DBS, --db DBS Database Number. Multiple databases can be provided.\nIf not specified, all databases will be included.\n-k KEYS, --key KEYS Keys to export. This can be a regular expression\n-o NOT_KEYS, --not-key NOT_KEYS\nKeys Not to export. This can be a regular expression\n-t TYPES, --type TYPES\nData types to include. Possible values are string,\nhash, set, sortedset, list. Multiple typees can be\nprovided. If not specified, all data types will be\nreturned\n-b BYTES, --bytes BYTES\nLimit memory output to keys greater to or equal to\nthis value (in bytes)\n-l LARGEST, --largest LARGEST\nLimit memory output to only the top N keys (by size)\n-e {raw,print,utf8,base64}, --escape {raw,print,utf8,base64}\nEscape strings to encoding: raw (default), print,\nutf8, or base64.\n-x, --no-expire With protocol command, remove expiry from all keys\n-a N, --amend-expire N\nWith protocol command, add N seconds to key expiry\ntime\n\n参数解析\n\n-c 执行命令 输出不同格式的数据\n\njson; 输出 json 格式的字符串 如： [{&quot;int&quot;:&quot;1&quot;}]\ndiff; 导出可供 diff 、kdiff 、 vimdiff 比较的数据\njustkeys; 只输出 key\njustkeyvals; 只输出键值对，以空格分隔\nmemory; 输出内存分布状态\nprotocol; 输出原始的 RESP 协议\n\n-f 指定输出到文件\n-n 指定输出的 db\n-k 指定输出哪些 key; 可以使用正则表达式， 如： '^users_\\d+$'\n-o 排除哪些 key; 可以使用正则表达式\n-t 指定输出 value 的类型\n-b 指定大于此字节数的 key 输出\n-l 输出最大的多少个 key\n-e 转义字符串到其他格式\n\nraw 原始字符串\nprint\nutf8 输出原始 utf8 格式字符串\nbase64 对于二进制数据来说，可以先 base64 存储到文件，然后在程序中 decode 出来\n\n-x 在导出 RESP 协议内容时，去掉过期时间\n-a 导出 RESP 协议内容时，给有过期时间的 key 加上几秒钟过期时间\n\n下面看一下一些常见用法：\n生成内存报告\nrdb --command memory dump.rdb &gt; memory.csv\n\n生成 CSV 格式的内存报告。包含的列有：\n数据库 ID，数据类型，key，内存使用量(byte)，编码。内存使用量包含 key、value 和其他值，结果：\ndatabase,type,key,size_in_bytes,encoding,num_elements,len_largest_element,expiry\n0,set,fruit,252,hashtable,2,6,\n0,hash,webset,81,ziplist,1,13,\n0,string,baiduyun,64,string,5,5,\n0,list,languages,161,quicklist,2,6,\n0,sortedset,page_rank,80,ziplist,1,9\n\n使用参数过滤想要的数据\n# 使用这个命令会将存储的 int 值显示为 json 的字符串\n&gt; rdb -c json --db 2 --type hash --key &quot;a.*&quot; /var/redis/6379/dump.rdb\n\n[{},{\n&quot;aroma&quot;:{&quot;pungent&quot;:&quot;vinegar&quot;,&quot;putrid&quot;:&quot;rotten eggs&quot;,&quot;floral&quot;:&quot;roses&quot;}}]\n\n比较两个 rdb 文件\n&gt; rdb --command diff /var/redis/6379/dump1.rdb | sort &gt; dump1.txt\n&gt; rdb --command diff /var/redis/6379/dump2.rdb | sort &gt; dump2.txt\n\n# 使用 diff 软件查看 diff\n&gt; kdiff3 dump1.txt dump2.txt\n\n查看一个 key 的内存使用情况\n&gt; redis-memory-for-key person:1\n\n&gt; redis-memory-for-key -s localhost -p 6379 -a mypassword person:1\n\nKey \t\t\tperson:1\nBytes\t\t\t\t111\nType\t\t\t\thash\nEncoding\t\t\tziplist\nNumber of Elements\t\t2\nLength of Largest Element\t8 # hash 中占用内存最大的那个 value 的占用字节数\n\n常见问题 FAQ\n\n内存报告的精确度如何？\n答：最多有 10% 的误差\n\n存储了一个二进制 binary 数据，但是输出的时候是乱码，不可读，怎么处理？\n答：可以使用 -e 命令先输出 base64 编码的字符串，然后程序中解码之后使用\n\n这个工具能解析哪个版本的 rdb 文件？\n答：2~6 版本\n\n我不想用 python，有其他的解析方案吗？\n答：\n\nredis-rdb is written in Ruby\nrdbhs is written in Haskell\nrdb-parser is written in Node.js\nrdb is written in Go\nrdb-rs is written in Rust\n参阅 rdb 文件格式 自己写一个解析\n\n参考\nhttps://github.com/sripathikrishnan/redis-rdb-tools",
		"tags": [ "note","redis","rdb"]
},

{
		"title": "202011281031 - 安装 rdbtools 工具",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/redis/202011281031 - 安装 rdbtools 工具/",
		"content": "202011281031 - 安装 rdbtools 工具\npip install rdbtools python-lzf\n\n或者\ngit clone https://github.com/sripathikrishnan/redis-rdb-tools\ncd redis-rdb-tools\nsudo python setup.py install",
		"tags": [ "note"]
},

{
		"title": "sar命令输出",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/sar命令输出/",
		"content": "sar命令输出\nLinux 6.8.0-44-generic (dy-turbo-vm) \t09/19/2024 \t_aarch64_\t(8 CPU)\n\n10:54:49 AM CPU %user %nice %system %iowait %steal %idle\n10:54:50 AM all 0.12 0.00 0.12 0.00 0.00 99.75\n10:54:51 AM all 0.00 0.00 0.25 0.00 0.00 99.75\n10:54:52 AM all 0.00 0.00 0.12 0.00 0.00 99.88\n10:54:53 AM all 0.00 0.00 0.12 0.00 0.00 99.88\n10:54:54 AM all 0.00 0.00 0.00 0.00 0.00 100.00\nAverage: all 0.03 0.00 0.13 0.00 0.00 99.85",
		"tags": [ "note"]
},

{
		"title": "shell-循环",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/shell-循环/",
		"content": "shell-循环\nfor\n\n# 遍历数字\nfor i in {0..10}; do\necho 133\ndone\n\n# 遍历文件\nfor file in split_??????; do\necho ${file}\ndone\n\n# 数组：\narr=(list0 list1 list2 list3)\n\n# 遍历数组\nfor list in ${arr[@]}; do\n\techo ${list}\ndone\n\nwhile\nwhile read line; do\necho $line\ndone &lt; file.txt",
		"tags": [ "note"]
},

{
		"title": "ubuntu 树莓派启动时配置网络",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/ubuntu 树莓派启动时配置网络/",
		"content": "ubuntu 树莓派启动时配置网络\n树莓派现在可以安装很多操作系统，其中 ubuntu 也提供了树莓派版本，因为对 ubuntu 更加熟悉，所以就往 SD 卡中烧录了 ubuntu 的 20.04 lts 64位 版本。这里有可供选择的操作系统。\n简单提一嘴烧录操作系统到 SD 卡上面的方法，树莓派提供了一个傻瓜式的软件给大家使用，直接打开之后选择系统，就可以烧录了，烧录过程大概会有几分钟。\n烧录完成之后，如果你按照树莓派官网的教程进行操作，肯定都行不通，因为树莓派的官方操作系统 Raspberry Pi OS 和 Ubuntu For Raspberry 上面的网络配置方式完全不一样。\n1 安装了 ubuntu 的树莓派怎么配置网络？\n打开你烧录好的 SD 卡\n找到 network-config 文件\n写入如下配置：\nwifis:\nwlan0:\ndhcp4: true\noptional: true\naccess-points:\n&lt;wifi network name&gt;:\npassword: &quot;&lt;wifi password&gt;&quot;\n\n如果是企业网络：\nwifis:\nwlan0:\ndhcp4: true\noptional: true\naccess-points:\n&lt;wifi network name&gt;:\nauth:\nkey-management: eap\nmethod: peap\nidentity: &quot;wudanyang&quot;\npassword: &quot;&quot;\n\n配置文件的格式\n修改完之后，把 SD 卡从电脑上弹出，然后插到树莓派里。\n不过，重启之后，你可能还是无法连接到网络。可以看下这里\n\nNote: During the first boot, your Raspberry Pi will try to connect to this network. It will fail the first time around. Simply reboot sudo reboot and it will work.\n\n引用ubuntu官网的一段话，第一次会失败，直接重启，第二次就能连上了。\n2 开启网络之后，如何登录树莓派？\n安装好之后默认用户名和密码都是 ubuntu\nssh ubuntu@&lt;raspberry ip&gt;\nip 地址的获取这里列举几种方法，不详细介绍：\n\n自己的路由器：登录后台查看分配的 ip\n局域网扫描（局域网机器不多的情况下）：\n\n下载个局域网扫描工具，如果局域网机器不多，会看到一个制造商为树莓派的 ip\n使用命令行 arp -a 挨个试一下\n\nubuntu 启动之后会使用 avahi 服务通过 mdns 协议在局域网注册一个域名 ubuntu.local，所以你可以这样登录 ssh ubuntu@ubuntu.local\n\n参考\n树莓派支持的操作系统\n树莓派操作系统烧录软件\n无屏幕和键盘配置树莓派WiFi和SSH\n百度百科-mdns\nMac通过网线直连控制树莓派 - lonerpaul - 博客园",
		"tags": [ "note"]
},

{
		"title": "vscode git 只暂存部分改动",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/vscode git 只暂存部分改动/",
		"content": "vscode git 只暂存部分改动\n可以只暂存这部分改动\n\nReference\nvisual studio code - How can I commit some changes to a file, but not others, in VSCode? - Stack Overflow",
		"tags": [ "note"]
},

{
		"title": "vscode 调试nginx代码",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/vscode 调试nginx代码/",
		"content": "内容\n修改 auto/cc/conf\nngx_compile_opt 中添加 -g\n修改后如下：\nngx_compile_opt=&quot;-c -g&quot;\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/vscode 调试nginx代码/#gcc-g\">#gcc -g 的作用</a>\n编译 &amp; 安装 &amp; 运行\n# prefix 是想要安装到的目录\nauto/configure --prefix=/home/ubuntu/mydisk/var/nginx-debug-1\n\n# 编译安装\nmake\nmake install\n\n修改配置\nvim /home/ubuntu/mydisk/var/nginx-debug-1/conf/nginx.conf\n将监听端口号改成 8080\nworker_processes 改成 1 (方便调试)\n启动 nginx\n/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\nnginx 的进程：\nps aux | grep nginx\nubuntu 17093 0.0 0.0 4184 372 ? Ss Mar30 0:00 nginx: master process /home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx\nubuntu 17094 0.0 0.0 4620 2316 ? S Mar30 0:00 nginx: worker process\nubuntu 46072 0.0 0.0 7692 648 pts/0 S+ 11:21 0:00 grep --color=auto nginx\n\n配置 vscode 调试\n{\n// 使用 IntelliSense 了解相关属性。\n// 悬停以查看现有属性的描述。\n// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n&quot;version&quot;: &quot;0.2.0&quot;,\n&quot;configurations&quot;: [\n{\n&quot;name&quot;: &quot;debug master&quot;,\n&quot;type&quot;: &quot;cppdbg&quot;,\n&quot;request&quot;: &quot;launch&quot;,\n&quot;program&quot;: &quot;/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx&quot;,\n&quot;args&quot;: [],\n&quot;stopAtEntry&quot;: true,\n&quot;cwd&quot;: &quot;${workspaceFolder}&quot;,\n&quot;environment&quot;: [],\n&quot;externalConsole&quot;: false,\n&quot;MIMode&quot;: &quot;gdb&quot;,\n&quot;setupCommands&quot;: [\n{\n&quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,\n&quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n&quot;ignoreFailures&quot;: true\n}\n]\n},\n{\n&quot;name&quot;: &quot;debug worker&quot;,\n&quot;type&quot;: &quot;cppdbg&quot;,\n&quot;request&quot;: &quot;attach&quot;,\n&quot;program&quot;: &quot;/home/ubuntu/mydisk/var/nginx-debug-1/sbin/nginx&quot;,\n&quot;processId&quot;: 17094,\n&quot;MIMode&quot;: &quot;gdb&quot;,\n&quot;setupCommands&quot;: [\n{\n&quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,\n&quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n&quot;ignoreFailures&quot;: true\n}\n]\n}\n]\n}\n\n在 worker 上调试需要改成 attach 的形式，并且使用了一次 attach 之后，就不能使用 strace -p 17094 查看系统调用了\n然后就可以打断点，进行单步调试了\n参考\nMac上用Visual Studio Code调试Nginx\ngcc -g 的作用\nGCC 参数详解-runoob\n在编译的时候会产生调试信息\nkernel.yama.ptrace_scope\nsysctl -a 查看内核参数\nkernel.yama.ptrace_scope\nhttps://www.kernel.org/doc/Documentation/security/Yama.txt\nsudo vim /etc/sysctl.d/10-ptrace.conf\nVSCode调试出现无法打开glibc库的“raise.c“或“abort.c“等文件的错误\nsudo strace 报 操作不被允许\nsudo strace -p 17094\nstrace: Could not attach to process. If your uid matches the uid of the target process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try again as the root user. For more details, see /etc/sysctl.d/10-ptrace.conf: Operation not permitted\nstrace: attach: ptrace(PTRACE_SEIZE, 17094): Operation not permitted\n\nhttps://stackoverflow.com/questions/19215177/how-to-solve-ptrace-operation-not-permitted-when-trying-to-attach-gdb-to-a-pro\nMaybe someone has attached this process with gdb.\n\nps -ef | grep gdb\n\ncan't gdb attach the same process twice.\n将 vscode 中的 调试关掉，就可以使用 strace 了\n如下图，可以看到，子进程停在了 epoll_pwait 系统调用上了",
		"tags": ["gcc", "note","nginx"]
},

{
		"title": "中断上下文切换详情",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/中断上下文切换详情/",
		"content": "中断上下文切换详情\n中断上下文切换是指当硬件或软件中断[1]发生时，操作系统需要暂停当前正在执行的任务，去处理中断事件的过程。与进程或线程上下文切换不同，中断上下文切换主要在用户态或内核态中断当前执行的任务，将 CPU 切换到中断处理程序执行。它是一种临时的、优先级很高的切换，不涉及切换到其他进程或线程的执行。\n1) 中断上下文切换的过程\n\n保存当前 CPU 寄存器状态:\n\n当中断发生时，CPU 会首先保存当前任务的部分寄存器状态，例如程序计数器（PC）、栈指针（SP）、标志寄存器等，以确保在中断处理完成后能够恢复到中断前的状态。这部分信息通常会被保存到内核栈中。\n\n切换到内核栈:\n\n中断处理是在内核态执行的，因此 CPU 会切换到当前任务的内核栈。每个进程或线程在内核中都有独立的内核栈。切换到内核栈后，中断处理程序可以安全地执行需要的内核操作。\n\n执行中断处理程序:\n\nCPU 切换到中断处理程序执行。中断处理程序可以是硬件中断处理（如键盘输入、中断时钟、网络数据到达等）或软件中断处理（如系统调用）。在这个阶段，处理程序可以执行与中断相关的操作，例如读取设备数据、更新状态等。\n\n恢复 CPU 状态:\n\n中断处理完成后，操作系统会恢复之前保存的 CPU 寄存器状态，包括程序计数器、通用寄存器、栈指针等，确保中断发生前的任务能够继续运行。\n\n返回中断前的执行:\n\n恢复到中断发生前的执行状态，继续执行中断前的任务。\n\n2) 中断上下文切换与进程/线程上下文切换的区别\n\n中断上下文切换只涉及当前执行任务的部分寄存器状态的保存与恢复，不涉及切换到其他进程或线程，因此通常比进程/线程上下文切换更轻量。\n中断上下文切换发生在内核态，其目的是快速处理硬件或软件中断，使系统能够及时响应外部事件。\n中断上下文不涉及虚拟内存空间的切换，因为中断处理程序运行在内核态，并且不关心哪个用户进程引发了中断。\n\n3) 中断上下文中的注意事项\n\n在中断上下文中，不允许执行阻塞操作（如等待 I/O、睡眠等），因为中断处理程序需要尽快完成，避免影响系统的实时性和性能。\n中断处理程序通常只完成必要的工作，其余的处理可能会被推迟到软中断或内核线程中，以减少中断处理的开销。\n\n4) 小结\n中断上下文切换是一个高优先级、临时的切换，用于处理外部事件（如硬件中断）。它会保存当前任务的部分 CPU 寄存器状态，然后切换到中断处理程序。处理完中断后，系统恢复中断前的执行状态，继续原来的任务。由于中断上下文切换并不涉及切换到其他进程或线程，它的开销相对较小。\n5) 参考\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/计算机中断/\">计算机中断</a> ↩︎",
		"tags": [ "note"]
},

{
		"title": "内存问题分析",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/内存问题分析/",
		"content": "内存问题分析\n找到内存问题的来源后，下一步就是相应的优化工作了。在我看来，内存调优最重要的就是，保证应用程序的热点数据放到内存中，并尽量减少换页和交换。\n常见的优化思路有这么几种。\n\n最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。\n减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等。尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问。\n使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽。\n通过 /proc/pid/oom_adj ，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死。\n\n参考资料\n21 | 套路篇：如何“快准狠”找到系统内存的问题？\n[短视频BS上线大批实例出现OOM现象问题](https://ku.baidu-int.com/knowledge/HFVrC7hq1Q/pKzJfZczuc/Gs4uNFcjEC/gzGld6QZrpsx1t)\n[Linux查看哪些进程占用的系统 buffer/cache 较高 (hcache，lsof）命令 - 陈咬金 - 博客园](https://www.cnblogs.com/zh94/p/11922714.html)\n[技术|在 Linux 上如何清除内存的 Cache、Buffer 和交换空间](https://linux.cn/article-5627-1.html)\n[tobert/pcstat: Page Cache stat: get page cache stats for files on Linux](https://github.com/tobert/pcstat)\n在 pcstat 基础上做的工具： [silenceshell/hcache: showing top X biggest cache files global](https://github.com/silenceshell/hcache)",
		"tags": [ "note"]
},

{
		"title": "202011192022 - 什么是卡片盒笔记法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011192022 - 什么是卡片盒笔记法/",
		"content": "202011192022 - 什么是卡片盒笔记法\n卡片盒笔记法是德国的一个社会学家发明的\n是一种处理笔记的流程\n将自己的想法感悟收集起来，\n然后使用卡片盒笔记法进行整理，\n建立笔记之间的联系\n以便于以后检索和使用",
		"tags": [ "note"]
},

{
		"title": "202011192023 - 卡片盒笔记法的基本元素",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011192023 - 卡片盒笔记法的基本元素/",
		"content": "202011192023 - 卡片盒笔记法的基本元素\n\n唯一 id ， id后面的标题： <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/20240417103919 卡片盒笔记法的标题是对内容的一句话描述/\">20240417103919 卡片盒笔记法的标题是对内容的一句话描述</a>\ntags 标签\n内容\n\nlinks 连接到其他的笔记\ncontent，使用自己的话写下这个想法\ncitation，引用，这个想法是从哪里得到的\n\n参考（对书籍等信息的参考）\n\nThe most important aspect of the body of the Zettel is that you write it in your own words.",
		"tags": [ "note"]
},

{
		"title": "202011201016 - 什么是知识和信息",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011201016 - 什么是知识和信息/",
		"content": "202011201016 - 什么是知识和信息\n\n202011222324 - 知识\n知识拿到之后，能让你有借鉴意义，能指导你的下一步工作，是活的\n知识是 how/why\n\n202011222325 - 信息\n信息是死的，一系列数据的陈列\n信息是 what/when/where/who\n信息是你应该被告诉什么是事情\n\n信息是回答“when，where，what，who”的问题，形成回答某个特定问题的文本，以及被解释具有某些意义的数字、事实、图像等形式的信息，更多关注对事实和数据的陈述。而知识是回答“how，why”的问题，能移积极地指导任务的执行和管理，进行决策和解决问题，更多关注人们如何解释信息的经验、偏见、运用的法则和价值标准。知识与信息的效用处于并列地位，没有层次之分。 ⤴️",
		"tags": [ "note"]
},

{
		"title": "202011201301 - 基础概念",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011201301 - 基础概念/",
		"content": "202011201301 - 基础概念\n四种卡片\n\n临时卡片，把自己的想法记录下来\n文献卡片，看书或者其他信息，觉得自己能用到就记录下来，注意，用自己的话来描述，不能复制粘贴或者剪藏\n永久卡片，将临时笔记和文献笔记组织成文，找出笔记之间的联系，将笔记放到卡片盒中\n项目卡片\n\n两种卡片盒\n\n知识卡片盒\n文献笔记盒",
		"tags": [ "note"]
},

{
		"title": "202011201315 - 卡片盒笔记法主要关注什么",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011201315 - 卡片盒笔记法主要关注什么/",
		"content": "202011201315 - 卡片盒笔记法主要关注什么\n\n链接 linking\n回顾 recalling\n索引 indexing\n\n参考\nZettelkasten In Notion &amp; How I Use Its Principles",
		"tags": [ "note"]
},

{
		"title": "202011210003 - 卡片盒笔记法的基本流程",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011210003 - 卡片盒笔记法的基本流程/",
		"content": "202011210003 - 卡片盒笔记法的基本流程\n#process\n\n记录：将自己的想法记录到临时卡片\n提炼：阅读书籍、资料的时候将内容记录到临时卡片\n参考：将参考目录加上一个简介\n整理：将记录的临时卡片和文献卡片通过链接联系起来\n\n建立链接，看一下你的永久笔记，有哪些能连接起来\n提炼索引\n建立入口\n\n回顾：定期进行回顾，通过双向链接回顾全篇文章\n产出：将卡片内容产出成文章\n\n选定一个主题，沿着链接将内容(链接)提炼出来",
		"tags": ["process", "note"]
},

{
		"title": "202011220028 - 从输出的角度看卡片盒笔记法的优势",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011220028 - 从输出的角度看卡片盒笔记法的优势/",
		"content": "202011220028 - 从输出的角度看卡片盒笔记法的优势\n\n从输出层面看，如果你在写作的时候才去找资料，那么很容易脱离主线，而如果你之前都整理好了资料，那么在写作的时候，只要顺着自己的卡片写下去就行了\n在输出的时候能够补全自己的盲点\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/20240408201701 卡片盒笔记法/\">20240408201701 卡片盒笔记法</a>\n参考\nhttps://www.zhihu.com/search?type=content&amp;q=Zettelkasten",
		"tags": [ "note"]
},

{
		"title": "202011222209 - 卡片盒笔记法的步骤",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011222209 - 卡片盒笔记法的步骤/",
		"content": "202011222209 - 卡片盒笔记法的步骤\n\n卡片盒笔记法的步骤？\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011210003 - 卡片盒笔记法的基本流程/\">202011210003 - 卡片盒笔记法的基本流程</a>\n参考\nhttps://blog.jimmylv.info/2020-06-03-zettelkasten-in-action/",
		"tags": [ "note"]
},

{
		"title": "202011222310 - 卡片盒笔记法的模块",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011222310 - 卡片盒笔记法的模块/",
		"content": "202011222310 - 卡片盒笔记法的模块\n\nInbox\nArchive\nReference Database\n\nInformation is the Basic Unit of Your Throughput\n\n如果没有输入，那么知识库就不会成长\n如果没有输出，那么知识库的增长就毫无意义\n参考\n卡片盒的构建模块",
		"tags": [ "note","zettelkasten"]
},

{
		"title": "202011222324 - 知识",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011222324 - 知识/",
		"content": "202011222324 - 知识\n知识拿到之后，能让你有借鉴意义，能指导你的下一步工作，是活的\n知识是 how/why",
		"tags": [ "note"]
},

{
		"title": "202011222325 - 信息",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011222325 - 信息/",
		"content": "202011222325 - 信息\n信息是死的，一系列数据的陈列\n信息是 what/when/where/who\n信息是你应该被告诉什么是事情",
		"tags": [ "note"]
},

{
		"title": "202011222338 - 使用卡片盒笔记法输出的流程",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011222338 - 使用卡片盒笔记法输出的流程/",
		"content": "tags: #output #process\n202011222338 - 使用卡片盒笔记法输出的流程\n\n整体看一下相关的知识\n为写作列出需要的大纲\n把永久笔记放到大纲中\n使用更多的知识（研究）填补空白，重复3-4步，直到满意为止\n根据提纲复制笔记到文档中\n重写你的手稿\n\n参考\nhttps://zettelkasten.de/posts/ease-into-writing/",
		"tags": ["output", "process", "note"]
},

{
		"title": "202011230004 - 如何写出容易理解的卡片",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/202011230004 - 如何写出容易理解的卡片/",
		"content": "tags: #zettelkasten #communicate\n一句话简单描述这张卡片：几年之后，你可能无法理解这张卡片，\n那么如何能做到更容易理解呢？\n202011230004 - 如何写出容易理解的卡片\n\n一个好的标题，可以是一种注释\n第一句话应该是关于此卡片的\n写的话要简单\n你是在教育你的卡片盒，他会在以后的某个时间点出来跟你对话\n想象一下，你是在跟以后的自己在对话\n\n参考\nhttps://zettelkasten.de/posts/how-to-write-notes-you-can-understand/",
		"tags": ["zettelkasten", "communicate", "note"]
},

{
		"title": "20240408201701 卡片盒笔记法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/20240408201701 卡片盒笔记法/",
		"content": "20240408201701 卡片盒笔记法\n#zettelkasten\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011192022 - 什么是卡片盒笔记法/\">202011192022 - 什么是卡片盒笔记法</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011201016 - 什么是知识和信息/\">202011201016 - 什么是知识和信息</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011201301 - 基础概念/\">202011201301 - 基础概念</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011192023 - 卡片盒笔记法的基本元素/\">202011192023 - 卡片盒笔记法的基本元素</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011210003 - 卡片盒笔记法的基本流程/\">202011210003 - 卡片盒笔记法的基本流程</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/卡片盒笔记法/202011201315 - 卡片盒笔记法主要关注什么/\">202011201315 - 卡片盒笔记法主要关注什么</a>\nReference\n\n什么是 zettelkasten 笔记\n基于 obsidian 的 zettelkasten 实践\n拆解Zettelkasten | 卡片盒知识管理体系实践反思\n聪明人怎么做笔记\n卡片盒笔记法豆瓣小组",
		"tags": ["zettelkasten", "note"]
},

{
		"title": "生成",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/卡片盒笔记法/生成/",
		"content": "tags: #how-to-learn\n一句话简单描述：自己想出一个答案，如果错了就给出反馈，纠正答案\n生成\n\n自己想出答案\n\n参考\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">认知天性</a>",
		"tags": ["how-to-learn", "note"]
},

{
		"title": "202404151420 哲学的分支",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/哲学/202404151420 哲学的分支/",
		"content": "202404151420 哲学的分支\n哲学是一个广泛的学科，包含多个分支，除了形而上学之外，还包括以下主要领域：\n\n认识论（Epistemology）：研究知识的性质、起源、范围和极限。认识论探讨我们如何知道什么是真实的，什么可以被认为是知识，以及我们如何获取知识。\n\n伦理学（Ethics）：探讨行为的道德性，即什么是对的，什么是错的。伦理学涉及到道德原则、价值观和好的生活方式的探讨。\n\n逻辑学（Logic）：研究有效推理的原则。逻辑学关注于如何构建有效的论证，以及如何区分有效论证和无效论证。\n\n政治哲学（Political Philosophy）：探讨政府、公民、政治权利、公正、法律、自由、正义等概念。政治哲学试图理解人类社会和政治结构的理想形态。\n\n美学（Aesthetics）：研究美和艺术的本质、经验和价值。美学涵盖了艺术作品的创造、欣赏和批评等方面。\n\n存在主义（Existentialism）：虽然更多被视为哲学的一个流派，但存在主义对个体存在、自由和选择的探讨对整个哲学领域有深远影响。\n\n心灵哲学（Philosophy of Mind）：研究心灵本质、心灵与身体的关系等问题。心灵哲学试图理解意识、感觉、感知和思维的本质。\n\n语言哲学（Philosophy of Language）：探索语言的本质、使用以及语言与现实之间的关系。语言哲学关注如何通过语言表达思想以及语言如何影响我们的理解和认识世界。\n\n科学哲学（Philosophy of Science）：分析科学的方法、目的和理论基础。它探讨了科学如何工作，以及科学知识的性质和局限性。\n\n这些领域相互交织，共同构成了哲学这一广泛的学科。每个领域都有其特定的研究问题和方法，但它们共同探讨人类知识和存在的基本问题。\n形而上学是哲学的一个核心分支，它探讨现实的最基本结构和本质。 词语“形而上学”（Metaphysics）源自拉丁语“Metaphysica”，最早可追溯到亚里士多德的作品集，意味着“超越自然之学”。形而上学关注那些超越物理科学研究范畴的问题，试图理解和解释存在的根本性质、宇宙的本质、事物存在的原因以及它们是如何存在的。",
		"tags": [ "note","哲学","aigc"]
},

{
		"title": "如何查看 nginx 的rewrite记录",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/如何查看 nginx 的rewrite记录/",
		"content": "如何查看 nginx 的rewrite记录\n设置 rewrite_log on;\n并且将error_log 的报错等级改成 notice;\n官网对 rewrite_log 的解释：\nSyntax:\trewrite_log on | off;\nDefault:\t\nrewrite_log off;\nContext:\thttp, server, location, if\nEnables or disables logging of ngx_http_rewrite_module module directives processing results into the error_log at the notice level.\n\n可以看到，这个指令只能在 http server location if 配置指令中使用，日志等级是 notice 写入到 error_log 配置的文件中。\n示例\nurl： /q?someparams\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+m/question(.*)?qid=\\d+(.*)?$&quot; does not match ...\n... 中间省略一些日志\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+question/(\\w+.*?)$&quot; does not match ...\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+q\\?(.*)?tn=nsatom_qb_main(.*)?$&quot; matches ...\n2021/04/22 18:21:28 [notice] 18131#0: *102982 &quot;^/+q&quot; matches ...\n2021/04/22 18:21:28 [notice] 18131#0: *102982 rewritten data: &quot;/q/q/q/q/q&quot;\n\n从上面的日志中可以看出，当触发了重写规则时，会有关键字 matches 否则会有 does not match 。\n最终重写完成之后，访问的地址会有标记：rewritten data\n这里就是 /q/q/q/q/q\n参考\nbest way to debug nginx rewrite rules in config file?\nnginx官方文档：Module ngx_http_rewrite_module",
		"tags": [ "note"]
},

{
		"title": "202409022041 神经网络过拟合了怎么办？",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/学习/202409022041 神经网络过拟合了怎么办？/",
		"content": "202409022041 神经网络过拟合了怎么办？\n(2 封私信 / 25 条消息) 【寻径06】如何突破学习瓶颈，为何打了10年游戏还是那么菜？ - 知乎: https://www.zhihu.com/zvideo/1447996778805714944?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=649223696263417856\n\n对应到人身上，\n\n第一个基本是别想了\n第二个是最好的方法\n第三个没看懂什么意思，不知道怎么操作",
		"tags": [ "note"]
},

{
		"title": "10x程序员工作法",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/10x程序员工作法/",
		"content": "10x程序员工作法\nContent\n以终为始\n\n倒着想\nDoD（Definition of Done 完成的定义）\n\n弥合差异\n个人的DoD，团队的DoD\nDoD 是一个思维模式，是一种尽可能消除不确定性，达成共识的方式。\nDoD 让我们能够在一开始就把“终”清晰地定义出来。\n在做任何事之前，先定义完成的标准。\n\n用户故事（User Story）\n\n标题\n概述\n详述\n验收标准\n在做任何需求或任务之前，先定好验收标准。\n\n持续集成\n\n尽早提交代码去集成。\n\n精益创业：产品经理不靠谱，你该怎么办？\n\nMVP 最小可行产品\n比较早成型的面向不确定创造新事物的方法论是精益创业，它提出了“开发（build）-测量（measure）-认知（learn）”这样一个反馈循环和最小可行产品的概念。\n如何试出来经过验证的认知\n精益创业提供给我们的是一个做产品的思考框架，我们能够接触到的大多数产品都可以放在这个框架内思考。\n默认所有需求都不做，直到弄清楚为什么要做这件事。\n\n上下文\n\n扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上。\n\n在动手做一件事之前，先推演一番。\n数字衡量\n\n从数字中发现问题，让系统更稳定。\n问一下自己，我的工作是不是可以用数字衡量。\n\n开发前的准备\n\n设计你的迭代0清单，给自己的项目做体检。\n\n任务分解\n\n动手做一个工作之前，请先对它进行任务分解。\n测试\n\n测试模型：冰淇淋蛋卷：\n金字塔模型：\n小事反馈周期短，而大事反馈周期长。\n多写单元测试。\n我们应该编写可测的代码。\n将任务拆小，越小越好。\n按照完整实现一个需求的顺序去安排分解出来的任务。\n什么是好的测试\n\n怎么衡量测试是否做好了呢？有一个标准：A-TRIP，这是五个单词的缩写，分别是Automatic（自动化）、Thorough（全面）、Repeatable（可重复的）、Independent（独立的）和 Professional（专业的）。\n要想写好测试，就要写简单的测试。\n\n需求分解\n\n需求估算-大小标准\n发现大的需求，一个迭代内做不完\n想要管理好需求，先把需求拆小。\n\n尽量做最重要的事。\n做好产品开发，最可行的方式是采用 MVP。\n\n沟通反馈\n\n对齐？信息对齐\n通过沟通反馈，不断升级自己的编解码能力。\n用业务的语言写代码。\n多面对面沟通，少开会。\n多尝试用可视化的方式进行沟通。\n定期复盘，找准问题根因，不断改善。\n多走近用户。\n事情往前做，有问题尽早暴露。\n金字塔原理\n多输出，让知识更有结构。\n\n自动化\n\n请谨慎地将工作自动化。\n有体系地学习运维知识。\n将验收测试自动化。\n把函数写短。\n构建好你的领域模型。\n用简单技术解决问题，直到问题变复杂。\n学习领域驱动设计。再去拆分微服务\n\n综合\n\n了解一个项目，从大图景开始。\n\n业务\n技术\n团队运作\n\n小步改造遗留系统，不要回到老路上。\n什么叫 T 型人？简言之，一专多能。\n在学习区工作和成长。\n\nReference\n39 面对遗留系统，你应该这样做\nhttps://learn.lianglianglee.com/专栏/10x程序员工作法/总复习 重新来“看书”.md",
		"tags": [ "note"]
},

{
		"title": "202404202259 Things 工作流",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/202404202259 Things 工作流/",
		"content": "202404202259 Things 工作流\n\n有任何事情都记录下来，心中的任何想法都不要放过，使用Things的快速录入功能\n定时整理收件箱（需要保证整理完收件箱之后，任务都是可执行的）\n\n如果有事情2分钟就能解决，那么直接去做，属于小事情\n如果需要1小时以上，就将任务设置成项目\n\n做一次任务分解，分解成小任务，小任务以30分钟以内完成最好\n如果分解项目本身也需要很多时间，那么在项目里面加一个【分解任务】的事项\n\n根据时间，选取任务进行处理，打开 Session 软件进行专注于做事，太喜欢 Session 的页面了，从而订阅了 setapp 使用\n\n为了让Things工作流更顺畅，我做了一个obsidian插件： <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/工具/obsidian-things3-today插件/\">obsidian-things3-today插件</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/节省时间/202404191548 GTD的主要思想/\">202404191548 GTD的主要思想</a>",
		"tags": [ "note","效率","tools","things3"]
},

{
		"title": "202405081331 mac 鼠须管 - rime 如何使用命令行执行同步操作",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/202405081331 mac 鼠须管 - rime 如何使用命令行执行同步操作/",
		"content": "202405081331 mac 鼠须管 - rime 如何使用命令行执行同步操作\n/Library/Input\\ Methods/Squirrel.app/Contents/MacOS/Squirrel --sync\n\n配置一个定时任务：\n# crontab -e\n0 22 * * * /Library/Input\\ Methods/Squirrel.app/Contents/MacOS/Squirrel --sync",
		"tags": [ "note","rime"]
},

{
		"title": "202409021102 marginnote 从 Web 网页导入内容",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/202409021102 marginnote 从 Web 网页导入内容/",
		"content": "202409021102 marginnote 从 Web 网页导入内容\n选择学习集或文件夹，点击导入按钮，选择【从Web网页】\n\n使用原始的页面样式，会比较难看，但是 MN 没有抓取页面部分的功能\n有一个折中方案，拖动右边的边框，将软件框变小，就变成了下面这样的图片，会比较好看一些\n\n点击软件下面中间的按钮，下载下来即可\n有时候代码片段等渲染不是很好\n这种情况只能使用 chrome 截图来解决了，在chrome中，可以开启开发者工具进行长截图\n\n利用 Chrome 原生工具进行网页长截图 - 一日一技 - 少数派\n#Omnivore\nRead on Omnivore\nRead Original\nNotes",
		"tags": ["Omnivore", "note","marginnote","阅读器"]
},

{
		"title": "202409022100 things3 与 mac 备忘录联动",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/202409022100 things3 与 mac 备忘录联动/",
		"content": "202409022100 things3 与 mac 备忘录联动\n\n在备忘录中选择【添加App链接】后，当打开对应的页面时，对应的备忘录会在右下角露出一个小图标",
		"tags": [ "note","things3","mac"]
},

{
		"title": "202404231624 如何在 Finder 中拷贝文件路径全称",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/mac/202404231624 如何在 Finder 中拷贝文件路径全称/",
		"content": "202404231624 如何在 Finder 中拷贝文件路径全称\n在文件上右键，按住 opt 键，点击&quot;将xxx拷贝为路径名称&quot;\n\n拷贝为下面的字符串：\n/Users/wudanyang/Downloads/WeTypeInstaller_1.1.0_322.zip",
		"tags": [ "note","mac"]
},

{
		"title": "mac-合上盖子不断网",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/mac/mac-合上盖子不断网/",
		"content": "mac-合上盖子不断网\n将电池的设置 【唤醒以供网络访问】改成【始终】就会生效了",
		"tags": [ "note","mac"]
},

{
		"title": "mac-自定义快捷键",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/mac/mac-自定义快捷键/",
		"content": "mac-自定义快捷键\n1 内容",
		"tags": [ "note","mac"]
},

{
		"title": "mac-获取程序名称-系统名称",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/mac/mac-获取程序名称-系统名称/",
		"content": "mac-获取程序名称-系统名称\n#mac\n\n在 raycast 中，可以更方便的取到进程名称，如，图中软件 copy 出来之后是： com.culturedcode.ThingsMac",
		"tags": ["mac", "note"]
},

{
		"title": "mac-鼠须管-使用lua脚本",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/mac/mac-鼠须管-使用lua脚本/",
		"content": "mac-鼠须管-使用lua脚本\n\n在 lua 目录中，添加脚本，以 date 日期文件为例：\n\n--[[\ndate_translator: 将 `date` 翻译为当前日期\n\ntranslator 的功能是将分好段的输入串翻译为一系列候选项。\n\n欲定义的 translator 包含三个输入参数：\n- input: 待翻译的字符串\n- seg: 包含 `start` 和 `_end` 两个属性，分别表示当前串在输入框中的起始和结束位置\n- env: 可选参数，表示 translator 所处的环境（本例没有体现）\n\ntranslator 的输出是若干候选项。\n与通常的函数使用 `return` 返回不同，translator 要求您使用 `yield` 产生候选项。\n\n`yield` 每次只能产生一个候选项。有多个候选时，可以多次使用 `yield` 。\n\n请看如下示例：\n--]]\n\nlocal function translator(input, seg)\n-- 如果输入串为 `date` 则翻译\nif (input == &quot;date&quot; or input == &quot;shijian&quot;) then\n--[[ 用 `yield` 产生一个候选项\n候选项的构造函数是 `Candidate`，它有五个参数：\n- type: 字符串，表示候选项的类型\n- start: 候选项对应的输入串的起始位置\n- _end: 候选项对应的输入串的结束位置\n- text: 候选项的文本\n- comment: 候选项的注释\n--]]\nyield(Candidate(&quot;date&quot;, seg.start, seg._end, os.date(&quot;%Y年%m月%d日&quot;), &quot;日期&quot;))\n--[[ 用 `yield` 再产生一个候选项\n最终的效果是输入法候选框中出现两个格式不同的当前日期的候选项。\n--]]\nyield(Candidate(&quot;date&quot;, seg.start, seg._end, os.date(&quot;%Y-%m-%d&quot;), &quot;日期&quot;))\nyield(Candidate(&quot;date&quot;, seg.start, seg._end, os.date(&quot;%Y-%m-%d %H:%M:%S&quot;), &quot;日期时间&quot;))\nend\nend\n\n-- 将上述定义导出\nreturn translator\n\nrime.lua 中引入此脚本:\n\n-- date_translator: 将 `date` 翻译为当前日期\n-- 详见 `lua/date.lua`:\ndate_translator = require(&quot;date&quot;)\n\n在 double_pinyin.custom.yaml 或 double_pinyin.schema.yaml 中配置上此处理程序\n\nengine/translators:\n- lua_translator@date_translator\n- lua_translator@week_translator\n- lua_translator@time_translator\n- lua_translator@number_translator\n- lua_translator@reverse_lookup_filter\n\n最终效果\n1 date\n\n2 time\n\n3 number\n输入 / ，然后输入数字 1，会显示大写数字\n\n参考\nhttps://github.com/hchunhui/librime-lua",
		"tags": [ "note","输入法"]
},

{
		"title": "接入外置键盘时如何关掉内置键盘",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/mac/接入外置键盘时如何关掉内置键盘/",
		"content": "接入外置键盘时如何关掉内置键盘\n\n下载： Karabiner-Elements\n连接外接设备后，点击 Disable the built-in keyboard while this device is connected 后面的按钮，即可达到此功能\n\n我主要是用在外置键盘放到mac键盘上面，防止误触",
		"tags": [ "note"]
},

{
		"title": "obsidian-things3-today插件",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/obsidian-things3-today插件/",
		"content": "obsidian-things3-today插件\n插件： Obsidian Plugin - Things3 Today\n\n把之前的插件重新搞了搞，把乱七八糟的东西去掉了，然后提交了obsidian插件库\nreview 审核通过： https://github.com/obsidianmd/obsidian-releases/pull/2997\n新录了一个gif：见github的readme，图中可以看到和things3的Today列表联动还算是顺畅\ngithub - wudanyang6/obsidian-things3-today\n跟着操作手册在论坛上面发了分享贴：\n\nhttps://forum.obsidian.md/t/new-plugin-things3-today-manage-todays-tasks-with-things3/77916",
		"tags": [ "note"]
},

{
		"title": "obsidian 开发过程支持的ICON",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/obsidian/obsidian 开发过程支持的ICON/",
		"content": "obsidian 开发过程支持的ICON\n\n[!info]- Icons\n\nadd-note-glyph\nany-key\naudio-file\nblocks\nbold-glyph\nbox-glyph\nbracket-glyph\nbroken-link\nbullet-list\nbullet-list-glyph\ncalendar-glyph\ncalendar-with-checkmark\ncheck-in-circle\ncheck-small\ncheckbox-glyph\ncheckmark\nclock\nclock-glyph\ncloud\ncode-glyph\ncommand-glyph\ncompress-glyph\ncreate-new\ncross\ncross-in-box\ncrossed-star\ndice\ndice-glyph\ndocument\ndocuments\ndot-network\ndouble-down-arrow-glyph\ndouble-up-arrow-glyph\ndown-arrow-with-tail\ndown-chevron-glyph\ndown-curly-arrow-glyph\nduplicate-glyph\nenlarge-glyph\nenter\nexit-fullscreen\nexpand-vertically\nfile-explorer-glyph\nfilled-pin\nfolder\nforward-arrow\nfullscreen\ngear\ngithub-glyph\ngo-to-file\ngraph-glyph\nhashtag\nheading-glyph\nhelp\nhighlight-glyph\nhorizontal-split\nimage-file\nimage-glyph\nimport-glyph\nindent-glyph\ninfo\ninstall\nitalic-glyph\nkeyboard-glyph\nlanguages\nleft-arrow\nleft-arrow-with-tail\nleft-chevron-glyph\nlines-of-text\nlink\nlink-glyph\nlinks-coming-in\nlinks-going-out\nlogo-crystal\nmagnifying-glass\nmerge-files\nmerge-files-glyph\nmicrophone\nmicrophone-filled\nminus-with-circle\nnavigate-glyph\nnote-glyph\nnumber-list-glyph\nopen-elsewhere-glyph\nopen-vault\npane-layout\npaper-plane\npaper-plane-glyph\npaste\npaste-text\npaused\npdf-file\npencil\npercent-sign-glyph\npin\nplay-audio-glyph\nplus-minus-glyph\nplus-with-circle\npopup-open\npresentation\npresentation-glyph\nprice-tag-glyph\nquestion-mark-glyph\nquote-glyph\nreading-glasses\nredo-glyph\nreset\nrestore-file-glyph\nright-arrow\nright-arrow-with-tail\nright-chevron-glyph\nright-triangle\nrun-command\nscissors\nscissors-glyph\nsearch\nsearch-glyph\nselect-all-text\nsheets-in-box\nsplit\nstacked-levels\nstar\nstar-glyph\nstar-list\nstop-audio-glyph\nstrikethrough-glyph\nswitch\nsync\nsync-small\ntag-glyph\nthree-horizontal-bars\ntomorrow-glyph\ntrash\ntwo-blank-pages\nundo-glyph\nunindent-glyph\nup-and-down-arrows\nup-arrow-with-tail\nup-chevron-glyph\nup-curly-arrow-glyph\nuppercase-lowercase-a\nvault\nvertical-split\nvertical-three-dots\nwand\nwand-glyph\nworkspace-glyph\nwrench-screwdriver-glyph\nyesterday-glyph\n\nIcon148Nameadd-note-glyphany-keyaudio-fileblocksbold-glyphbox-glyphbracket-glyphbroken-linkbullet-listbullet-list-glyphcalendar-glyphcalendar-with-checkmarkcheck-in-circlecheck-smallcheckbox-glyphcheckmarkclockclock-glyphcloudcode-glyphcommand-glyphcompress-glyphcreate-newcrosscross-in-boxcrossed-stardicedice-glyphdocumentdocumentsdot-networkdouble-down-arrow-glyphdouble-up-arrow-glyphdown-arrow-with-taildown-chevron-glyphdown-curly-arrow-glyphduplicate-glyphenlarge-glyphenterexit-fullscreenexpand-verticallyfile-explorer-glyphfilled-pinfolderforward-arrowfullscreengeargithub-glyphgo-to-filegraph-glyphhashtagheading-glyphhelphighlight-glyphhorizontal-splitimage-fileimage-glyphimport-glyphindent-glyphinfoinstallitalic-glyphkeyboard-glyphlanguagesleft-arrowleft-arrow-with-tailleft-chevron-glyphlines-of-textlinklink-glyphlinks-coming-inlinks-going-outlogo-crystalmagnifying-glassmerge-filesmerge-files-glyphmicrophonemicrophone-filledminus-with-circlenavigate-glyphnote-glyphnumber-list-glyphopen-elsewhere-glyphopen-vaultpane-layoutpaper-planepaper-plane-glyphpastepaste-textpausedpdf-filepencilpercent-sign-glyphpinplay-audio-glyphplus-minus-glyphplus-with-circlepopup-openpresentationpresentation-glyphprice-tag-glyphquestion-mark-glyphquote-glyphreading-glassesredo-glyphresetrestore-file-glyphright-arrowright-arrow-with-tailright-chevron-glyphright-trianglerun-commandscissorsscissors-glyphsearchsearch-glyphselect-all-textsheets-in-boxsplitstacked-levelsstarstar-glyphstar-liststop-audio-glyphstrikethrough-glyphswitchsyncsync-smalltag-glyphthree-horizontal-barstomorrow-glyphtrashtwo-blank-pagesundo-glyphunindent-glyphup-and-down-arrowsup-arrow-with-tailup-chevron-glyphup-curly-arrow-glyphuppercase-lowercase-avaultvertical-splitvertical-three-dotswandwand-glyphworkspace-glyphwrench-screwdriver-glyphyesterday-glyph\nReference",
		"tags": [ "note"]
},

{
		"title": "不打开obsidian的情况下记录当前事件",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/obsidian/不打开obsidian的情况下记录当前事件/",
		"content": "不打开obsidian的情况下记录当前事件\n将输入设置成你想附带的文本，传入内容改成“作为参数”\n加上 open --background &quot;$1&quot; 即可实现在不将 obsidian 放到前台的情况下记录日志。\n\n使用这种方法 obsidian 不会到前台占用注意力，不过仍然会将对应的操作完成\n参考\nLeave Obsidian in background when making URI call? - Developers &amp; API - Obsidian Forum",
		"tags": [ "note"]
},

{
		"title": "phpstorm 两下 ctrl 可以快速运行程序",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/phpstorm 两下 ctrl 可以快速运行程序/",
		"content": "phpstorm 两下 ctrl 可以快速运行程序\n\n在 phpstorm 中的工具栏中，有一个绿色的按钮，可以运行已经定义好的配置\n但是每次切换的时候，都需要点一下切换到具体的程序\n但是如果双击 ctrl 就可以直接弹出运行的搜索栏\n\n在搜索栏中输入你想运行的程序，上下键选中，然后 enter 即可运行",
		"tags": [ "note","phpstorm","ide","tools"]
},

{
		"title": "vim显示列分隔符",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/vim显示列分隔符/",
		"content": "vim显示列分隔符\n:set list\n\n显示 tab 和结尾符号 $，不显示开头的 ^ 符号",
		"tags": [ "note"]
},

{
		"title": "vscode vim 状态下显示提示",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/vscode vim 状态下显示提示/",
		"content": "vscode vim 状态下显示提示\nvisual studio code - Keyboard shortcut to show hover tooltip - Stack Overflow\n\nIf you're using the VSCodeVim plugin, you can use gh to show the tooltip.\n\n如下图所示，光标所在位置，平常是需要鼠标移动刀红色波浪线位置后才出现这个提示，在使用VSCodeVim的情况下，按下gh可以调出此弹窗快速查看错误提示信息",
		"tags": [ "note"]
},

{
		"title": "创建一个chrome独立APP窗口",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/工具/创建一个chrome独立APP窗口/",
		"content": "创建一个chrome独立APP窗口\n创建出的窗口本质还是一个 chrome 网页，但是比较方便使用\n按步骤操作：\n\n点击 chrome 右上角的三个点\n点击保存并分享\n点击创建快捷方式\n在弹窗中勾选 在窗口打开，点击创建\n即可得到一个独立 APP 窗口\n\n弹窗出来之后，选择 在窗口中打开\n\n就会得到一个独立软件一样的百度\n\nReference",
		"tags": [ "note","chrome"]
},

{
		"title": "202404171707 当你学不下去的时候",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/思考/202404171707 当你学不下去的时候/",
		"content": "202404171707 当你学不下去的时候\n当你学不下去的时候，闭上眼，想象高考刚刚出分，没考上，你崩溃大哭，问能不能再给我一次机会。睁开眼，这就是你新的机会。",
		"tags": [ "note"]
},

{
		"title": "搜索引擎技巧",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/搜索引擎技巧/",
		"content": "搜索引擎技巧\n在使用搜索时，可选用的几个参数\n\n双引号限定关键词 图片&quot;你好&quot;\nintitle 标题关键词 intitle:你好\nallintitle 多个标题关键词 allintitle:你好 世界\nintext 内容关键词 intext:世界\ninurl 网址关键词 inurl:nginx\nsite 限定网站域名 site:github.com\nimagesize 限定尺寸 imagesize:1920x1080 风景\nfiletype 文件格式 filetype:pdf OR filetype:doc 机器学习教程",
		"tags": [ "note"]
},

{
		"title": "202409121624 Linux 性能分析优化-CPU",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/202409121624 Linux 性能分析优化-CPU/",
		"content": "202409121624 Linux 性能分析优化-CPU\n1 Linux 系统概览\n1.1 CPU 概览\n冯诺依曼结构：\n\nCPU大概内部结构：\n\n1.2 Linux 内核概览\n\n2 基本概念\n2.1 平均负载\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/CPU 平均负载/\">CPU 平均负载</a>\n2.2 CPU 使用率\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/CPU 使用率/\">CPU 使用率</a>\n2.3 CPU 上下文切换\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/CPU 上下文切换/\">CPU 上下文切换</a>\n2.4 中断\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/计算机中断/\">计算机中断</a>\n3 CPU 使用率过高如何排查\n\n通过top ps pidstat 找到 CPU 使用率过高的进程 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/CPU 使用率/#4-cpu\">CPU 使用率#4) 获得CPU使用率的几种方法</a>\n\n找到占用 CPU 最多的函数\n\n使用GDB或者其他Debug工具进行调试\n使用 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/linux-perf/\">linux-perf</a>\n\n针对突发进程如何处理呢？\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/模拟突发进程特别多的情况/\">模拟突发进程特别多的情况</a>\n\n开启终端，演示突发进程的现象\n\ntop 直接查看，无法发现具体哪个进程的问题\n几种观测突发进程的方法\n\n使用 top -b -c 输出到文件，然后分析文件内容\n使用 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/linux-perf/\">linux-perf</a> 记录一段时间的内容，然后通过 report 查看 cpu 使用率\n\n观察到了CPU使用率比较高的command之后，可以使用 pstree 找到对应的父进程\n\n使用 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/linux-execsnoop/\">linux-execsnoop</a> 观测 exec 生成的新进程\n\n软中断CPU使用率升高如何排查\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/模拟软中断特别多的情况/\">模拟软中断特别多的情况</a>\ntop 看 si st 使用率\n\ncat /proc/softirqs 查看软硬中断的情况，观察是什么类型的中断上涨比较多 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/计算机中断/#3-3-1\">计算机中断#3.3.1) 查看中断</a>\n\n一般情况下，都是网络问题，可以使用 sar -n DEV 1 观察输入输出包的速度\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/快速分析系统CPU瓶颈的命令工具/\">快速分析系统CPU瓶颈的命令工具</a>\n\n4 性能优化的思路\n参考之前的分享： <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">QB性能优化指南</a>\n5 参考\n\nLinux 性能优化实战: https://time.geekbang.org/column/intro/100020901?tab=catalog\nLinux man pages online: https://man7.org/linux/man-pages/index.html\n第八章 CPU的结构和功能_排队器是在cpu中的吗-CSDN博客: https://blog.csdn.net/qq_45091353/article/details/127096768",
		"tags": [ "note"]
},

{
		"title": "CPU 上下文切换",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/CPU 上下文切换/",
		"content": "CPU 上下文切换\n上下文切换（Context Switch） 是操作系统中，当 CPU 在多个进程或线程之间切换执行时发生的操作。它是多任务系统实现并发执行的核心机制之一。\n上下文 是指 CPU 运行一个进程或线程时的状态，包括以下内容：\n\n寄存器：存储当前进程的运行状态（如指令指针、程序计数器、栈指针等）。\n内存映射：包括进程的地址空间、虚拟内存页表等。\nCPU 状态：进程当前的运行模式（用户态或内核态）。\n进程控制块（PCB）：保存进程的上下文信息。\n\n上下文切换的场景：\n\n进程上下文切换：当操作系统调度器决定暂停一个进程并切换到另一个进程时，需要保存当前进程的上下文，并恢复目标进程的上下文。\n线程上下文切换：线程属于同一个进程，但每个线程有自己独立的执行上下文（如寄存器状态、栈指针），切换时也会涉及上下文保存与恢复。\n中断上下文处理：当硬件或软件中断发生时，CPU 会暂停当前进程处理中断，完成后恢复原进程的上下文。\n\n上下文切换的步骤：\n\n保存上下文：将当前进程/线程的寄存器、栈指针等信息保存到进程控制块（PCB）中。\n加载新上下文：从目标进程的 PCB 中加载该进程的寄存器状态、栈指针等信息。\n切换内存映射：切换虚拟内存的页表，以确保 CPU 访问的是新进程的内存空间。\n\n上下文切换的开销： 上下文切换涉及保存和恢复进程状态、切换内存映射等操作，这需要 CPU 额外的时间。频繁的上下文切换会导致性能下降，因为每次切换时，CPU 需要停下来保存/加载状态，而不是执行有用的工作。因此，系统设计通常会尽量减少不必要的上下文切换。\n1 进程上下文切换\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/进程上下文切换详情/\">进程上下文切换详情</a>\n调度的时机：\n\n进程进行系统调用时，可能会发生<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/系统调用时上下文调度/\">系统调用时上下文调度</a>\n时间片耗尽\n进程阻塞\n优先级调度\n中断\n\n2 线程上下文切换\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/线程上下文切换详情/\">线程上下文切换详情</a>\n\n线程属于不同的进程\n\n同进程上下文调度\n\n线程间属于同一进程\n\n共享相同的虚拟内存、全局变量等资源\n切换栈、寄存器等线程私有数据\n\n3 中断上下文切换\n<a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/中断上下文切换详情/\">中断上下文切换详情</a>\n\n硬件&amp;软件中断时\n优先级比进程、线程优先级高\n中断只需要内核态的状态，CPU 寄存器，内核堆栈，硬件中断参数等\n\n4 CPU 上下文切换的问题\n会将大量的CPU时间浪费保存和恢复程序状态上面，缩短真正的运行时间，导致系统整体性能大幅下降\n5 查看CPU上下文切换\n# CPU 上下文切换\nvmstat 5\n\n输出内容：\nprocs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------\nr b swpd free buff cache si so bi bo in cs us sy id wa st gu\n1 0 0 3230412 44980 526092 0 0 5 8 49 0 0 0 99 0 0 0\n\n内容含义查看：\nvmstat(8) - Linux 手册页 --- vmstat(8) - Linux manual page: https://man7.org/linux/man-pages/man8/vmstat.8.html\n重要字段：\n\ncs（context switch）是每秒上下文切换的次数。\nin（interrupt）则是每秒中断的次数。\nr（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。\nb（Blocked）则是处于不可中断睡眠状态的进程数。\n\npidstat -w 5\n\n内容输出：\nLinux 6.8.0-44-generic (dy-turbo-vm) \t09/14/2024 \t_aarch64_\t(2 CPU)\n\n11:54:39 AM UID PID cswch/s nvcswch/s Command\n11:54:44 AM 0 16 0.20 0.00 ksoftirqd/0\n11:54:44 AM 0 17 0.40 0.00 rcu_preempt\n11:54:44 AM 0 18 0.40 0.00 migration/0\n11:54:44 AM 0 23 0.40 0.00 migration/1\n11:54:44 AM 0 34 1.98 0.00 kcompactd0\n11:54:44 AM 0 48 0.20 0.00 kworker/0:1H-kblockd\n11:54:44 AM 0 470 1.39 0.00 multipathd\n11:54:44 AM 0 712 10.69 0.00 vmtoolsd\n11:54:44 AM 0 5892 3.17 0.00 kworker/0:1-events\n11:54:44 AM 0 6488 1.98 0.00 kworker/u4:0-events_power_efficient\n11:54:44 AM 0 6501 6.34 0.00 kworker/1:3-events\n11:54:44 AM 0 6677 4.75 0.00 kworker/u4:2-events_unbound\n11:54:44 AM 1000 6969 18.22 0.00 sshd\n11:54:44 AM 1000 7085 0.20 0.00 pidstat\n\npidstat(1) - Linux manual page: https://man7.org/linux/man-pages/man1/pidstat.1.html\n重要字段：\n\ncswch/s ： 每秒自愿上下文切换次数（自愿：I/O等待，申请内存等需要等待资源ready的操作）\nnvcswch/s ： 每秒非自愿上下文切换次数（非资源：时间片达到等）",
		"tags": [ "note"]
},

{
		"title": "CPU 使用率",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/CPU 使用率/",
		"content": "CPU 使用率\nCPU 使用率（CPU Utilization）是指在一段时间内，处理器用于执行任务的时间占总时间的比例。它反映了 CPU 的繁忙程度，通常以百分比表示。\n1 基本概念：\n\n用户态（User Mode）CPU 使用率：\n\nCPU 在用户态（用户空间）运行用户应用程序的时间。\n例如，当你运行一个程序（如文本编辑器、浏览器等）时，CPU 会在用户态处理这些任务。\n\n系统态（System Mode）CPU 使用率：\n\nCPU 在内核态（内核空间）执行系统调用、驱动程序等操作的时间。\n例如，文件读写操作、网络请求处理等属于内核态。\n\n空闲态（Idle）CPU 使用率：\n\nCPU 处于空闲状态，没有任务要执行的时间。\n这个数值越大，表示 CPU 越空闲。\n\n等待 I/O（I/O Wait）：\n\nCPU 等待输入输出（如硬盘、网络）的时间。这种情况下，CPU 可能是空闲的，但由于等待 I/O 完成而无法进行其他任务。\n\n中断时间（IRQ &amp; SoftIRQ）：\n\nCPU 处理硬件中断（IRQ）和软件中断（SoftIRQ）的时间。\n\n高 CPU 使用率的含义：\n\n高 CPU 使用率意味着系统在执行大量的计算任务，可能是正常现象（例如运行密集型计算任务），也可能是系统负载过高。\n低 CPU 使用率则表明系统相对空闲，CPU 大部分时间处于空闲状态。\n\n如何查看 CPU 使用率：\n\n使用 top 或 htop 等工具可以实时监控 CPU 的使用情况。\n使用 mpstat 可以更详细地查看每个 CPU 核心的使用率。\n\n2 如何查看CPU时间\ncat /proc/stat 查看开机以来的系统CPU时间 /proc/stat\n\nThe amount of time, measured in units of USER_HZ\n(1/100ths of a second on most architectures, use\nsysconf(SC_CLK_TCK) to obtain the right value),\nthat the system (&quot;cpu&quot; line) or the specific CPU\n(&quot;cpu_N&quot; line) spent in various states\n\n单位为时间数量，一般是 1/100 秒，具体值根据 USER_HZ 确定。\n3 CPU 使用率的计算方法\n总CPU使用率（开机以来）\n使用率空闲时间总时间CPU 使用率=1−空闲时间总 CPU 时间一段时间内的平均CPU使用率\n平均使用率空闲时间空闲时间总时间总时间平均 CPU 使用率=1−空闲时间new−空闲时间old总 CPU 时间new−总 CPU 时间old4 获得CPU使用率的几种方法\n\ntop命令\n按1可以看每个CPU单独的数据 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">linux-top</a>\nhtop 命令\n优势：可以响应鼠标点击事件，滚动查看，查看进程树\nvmstat 1 每秒输出一次 vmstat reports information about processes, memory, paging, block IO, traps, disks and cpu activity\nmpstat 或者 mpstat -u 1 10 获取一段时间内的CPU使用率\n\nmpstat命令输出\nLinux 6.8.0-44-generic (dy-turbo-vm) \t09/19/2024 \t_aarch64_\t(8 CPU)\n\n10:52:27 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle\n10:52:27 AM all 0.02 0.00 0.05 0.01 0.00 0.00 0.00 0.00 0.00 99.91\n\nsar 1 5 此命令每秒采集一次数据，连续采集 5 次。\n\nsar命令输出\nLinux 6.8.0-44-generic (dy-turbo-vm) \t09/19/2024 \t_aarch64_\t(8 CPU)\n\n10:54:49 AM CPU %user %nice %system %iowait %steal %idle\n10:54:50 AM all 0.12 0.00 0.12 0.00 0.00 99.75\n10:54:51 AM all 0.00 0.00 0.25 0.00 0.00 99.75\n10:54:52 AM all 0.00 0.00 0.12 0.00 0.00 99.88\n10:54:53 AM all 0.00 0.00 0.12 0.00 0.00 99.88\n10:54:54 AM all 0.00 0.00 0.00 0.00 0.00 100.00\nAverage: all 0.03 0.00 0.13 0.00 0.00 99.85\n\nps： ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head\ncat /proc/stat 通过读取CPU时间，自行计算CPU使用率\n查看指定进程的CPU使用情况： <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/linux-pidstat/\">linux-pidstat</a>",
		"tags": [ "note"]
},

{
		"title": "CPU 平均负载",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/CPU 平均负载/",
		"content": "CPU 平均负载\n1 什么是平均负载?\n\nSystem load averages is the average number of processes that are\neither in a runnable or uninterruptable state. A process in a\nrunnable state is either using the CPU or waiting to use the CPU.\nA process in uninterruptable state is waiting for some I/O\naccess, eg waiting for disk. The averages are taken over the\nthree time intervals. Load averages are not normalized for the\nnumber of CPUs in a system, so a load average of 1 means a single\nCPU system is loaded all the time while on a 4 CPU system it\nmeans it was idle 75% of the time.\nhttps://man7.org/linux/man-pages/man1/uptime.1.html\n\n简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数\n2 如何查看linux平均负载\n\ntop\nuptime\nw\ncat /proc/loadavg\n\n# CPU 平均负载\nload average: 0.62, 0.72, 0.76\n\n3 平均负载的高低判断标准\n最理想的，就是每个 CPU 上都刚好运行着一个进程\n所以说平均负载高不高，需要看你的 CPU 到底有几个\nCPU个数查询： cat /proc/cpuinfo\n4 参考\n\nCPU比喻成一辆地铁，正在使用CPU的进程就是在地铁上的人；等待CPU的进程就是在下一站等地铁来的人；等待I/O的进程就是在下一站要上车和下车的人，虽然现在对CPU没影响，可未来会影响，所以也要考虑到平均负载上。\n\n02 | 基础篇：到底应该怎么理解“平均负载”？-Linux 性能优化实战-极客时间: https://time.geekbang.org/column/article/69618",
		"tags": [ "note"]
},

{
		"title": "linux-execsnoop",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/linux-execsnoop/",
		"content": "linux-execsnoop\n\n[!NOTE]\nexecsnoop - Trace new processes via exec() syscalls. Uses Linux eBPF/bcc.\n\n适合查看系统中突发进程比较多的情况\nwudanyang@dy-turbo-vm:~$ sudo execsnoop\n[sudo] password for wudanyang:\nPCOMM PID PPID RET ARGS\nstress 17095 1351 0 /usr/bin/stress\nstress 17097 1351 0 /usr/bin/stress\nstress 17099 1351 0 /usr/bin/stress -t 1 -d\nstress 17101 1351 0 /usr/bin/stress\nstress 17103 1351 0\nstress 17105 1351 0 /usr/bin/stress -t\nstress 17107 1351 0 /usr/bin/stress -t\nstress 17109 1351 0 /usr/bin/stress -t\nstress 17111 1351 0 /usr/bin/stress -t 1 -d\nstress 17113 1351 0 /usr/bin/stress\nstress 17115 1351 0\nstress 17117 1351 0 /usr/bin/stress -t 1\nstress 17119 1351 0 /usr/bin/stress -t 1 -d 1\nstress 17121 1351 0 /usr/bin/stress\nstress 17123 1351 0 /usr/bin/stress -t 1 -d\nstress 17125 1351 0 /usr/bin/stress -t\nstress 17127 1351 0\nstress 17129 1351 0 /usr/bin/stress -t 1\nstress 17131 1351 0 /usr/bin/stress -t 1 -d 1\nstress 17133 1351 0 /usr/bin/stress\nstress 17135 1351 0 /usr/bin/stress\nstress 17137 1351 0 /usr/bin/stress",
		"tags": [ "note","linux命令"]
},

{
		"title": "linux-perf",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/linux-perf/",
		"content": "linux-perf\nlinux 下的性能分析工具\n1 perf top\n显示占用 cpu 时钟最多的函数或指令，可以用来查找热点函数\n\n表头四个字段：\n\nOverhead 百分比\nShared 该函数或指令所在的动态共享对象（dynamic Shared Object）\nObject 动态对象类型，[.] 代表用户空间可执行程序、动态链接库，[k] 代表内核空间\nSymbol 符号名，函数名。\n\n2 常用命令\n记录当前状态\nperf record -a -g -- sleep 30\n\n产出一份图标报告\nperf report -g graph,0\n\n3 参考\nhttps://time.geekbang.org/column/article/70476",
		"tags": [ "note"]
},

{
		"title": "快速分析系统CPU瓶颈的命令工具",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/快速分析系统CPU瓶颈的命令工具/",
		"content": "快速分析系统CPU瓶颈的命令工具\n\n1 参考\n\n11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？-Linux 性能优化实战-极客时间: https://time.geekbang.org/column/article/72685",
		"tags": [ "note"]
},

{
		"title": "模拟突发进程特别多的情况",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/模拟突发进程特别多的情况/",
		"content": "模拟突发进程特别多的情况\n突发进程特别多的情况构建：\n# 如果无写入权限，iowait 都不会升高，否则 wa 使用率值升高\n# top 中只能看到 us 使用率值升高非常多\n# 无法观测到具体什么进程CPU使用率较高\n# 因为全是突发进程\nwhile true;do stress -t 1 -d 1 2&gt;&amp;1 ;done",
		"tags": [ "note"]
},

{
		"title": "模拟软中断特别多的情况",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/模拟软中断特别多的情况/",
		"content": "模拟软中断特别多的情况\n1 客户端请求\nsudo hping -S -p 8080 -i u100 192.168.135.130\n\n# 如果上面的命令没有显著提高软中断的占用率，可以将 -i 间隔取消，加上 --flood 忽略回复消息\nsudo hping -S -p 8080 --flood 192.168.135.130\n\n2 服务端情况\nwatch -d cat /proc/softirqs\n\n观察服务端软中断情况",
		"tags": [ "note"]
},

{
		"title": "硬件中断输出示例",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/操作系统/CPU性能优化/硬件中断输出示例/",
		"content": "硬件中断输出示例\ncat /proc/interrupts\nCPU0 CPU1\n10: 690796 792946 GICv3 27 Level arch_timer\n12: 0 0 MSI 344064 Edge PCIe PME, pciehp\n13: 0 0 MSI 346112 Edge PCIe PME, pciehp\n14: 0 0 MSI 348160 Edge PCIe PME, pciehp\n15: 0 0 MSI 350208 Edge PCIe PME, pciehp\n16: 0 0 MSI 352256 Edge PCIe PME, pciehp\n17: 0 0 MSI 354304 Edge PCIe PME, pciehp\n18: 0 0 MSI 356352 Edge PCIe PME, pciehp\n19: 0 0 MSI 358400 Edge PCIe PME, pciehp\n20: 0 0 MSI 360448 Edge PCIe PME, pciehp\n21: 0 0 MSI 362496 Edge PCIe PME, pciehp\n22: 0 0 MSI 364544 Edge PCIe PME, pciehp\n23: 0 0 MSI 366592 Edge PCIe PME, pciehp\n24: 0 0 MSI 368640 Edge PCIe PME, pciehp\n25: 0 0 MSI 370688 Edge PCIe PME, pciehp\n26: 0 0 MSI 372736 Edge PCIe PME, pciehp\n27: 0 0 MSI 374784 Edge PCIe PME, pciehp\n28: 0 0 MSI 376832 Edge PCIe PME, pciehp\n29: 0 0 MSI 378880 Edge PCIe PME, pciehp\n30: 0 0 MSI 380928 Edge PCIe PME, pciehp\n31: 0 0 MSI 382976 Edge PCIe PME, pciehp\n32: 0 0 MSI 385024 Edge PCIe PME, pciehp\n33: 0 0 MSI 387072 Edge PCIe PME, pciehp\n34: 0 0 MSI 389120 Edge PCIe PME, pciehp\n35: 0 0 MSI 391168 Edge PCIe PME, pciehp\n36: 0 0 MSI 393216 Edge PCIe PME, pciehp\n37: 0 0 MSI 395264 Edge PCIe PME, pciehp\n38: 0 0 MSI 397312 Edge PCIe PME, pciehp\n39: 0 0 MSI 399360 Edge PCIe PME, pciehp\n40: 0 0 MSI 401408 Edge PCIe PME, pciehp\n41: 0 0 MSI 403456 Edge PCIe PME, pciehp\n42: 0 0 MSI 405504 Edge PCIe PME, pciehp\n43: 0 0 MSI 407552 Edge PCIe PME, pciehp\n44: 0 0 GICv3 32 Level ehci_hcd:usb1\n46: 0 0 GICv3 23 Level arm-pmu\n48: 81341 0 MSI 1048576 Edge ens160-rx-0\n49: 61793 0 MSI 1048577 Edge ens160-tx-0\n50: 7 0 MSI 1048578 Edge ens160\n51: 13113 0 MSI 573440 Edge ahci[0000:01:03.0]\n52: 116 0 MSI 9437184 Edge nvme0q0\n53: 14025 0 MSI 9437185 Edge nvme0q1\n54: 0 15724 MSI 9437186 Edge nvme0q2\n56: 232 0 MSI 5242880 Edge xhci_hcd\n59: 3364 0 MSI 14336 Edge vmw_vmci\n60: 0 0 MSI 14337 Edge vmw_vmci\n61: 6732 0 MSI 14338 Edge vmw_vmci\n62: 0 0 MSI 245760 Edge vmwgfx\n63: 0 0 MSI 245761 Edge vmwgfx\n64: 0 0 MSI 245762 Edge vmwgfx\n65: 0 0 MSI 245763 Edge vmwgfx\n66: 0 0 MSI 245764 Edge vmwgfx\n67: 0 0 MSI 245765 Edge vmwgfx\n68: 315 0 MSI 540672 Edge snd_hda_intel:card0\nIPI0: 9633 18455 Rescheduling interrupts\nIPI1: 133913 157019 Function call interrupts\nIPI2: 0 0 CPU stop interrupts\nIPI3: 0 0 CPU stop (for crash dump) interrupts\nIPI4: 0 0 Timer broadcast interrupts\nIPI5: 198 2356 IRQ work interrupts\n\n/proc/interrupts 文件记录了系统中各个中断源的触发情况。根据你提供的内容，以下是该文件中各个字段的解释：\n1) 字段解析\n\n中断号（IRQ Number）：\n\n第一列表示每个中断的唯一标识符。中断号以数字表示，例如 10, 12, 13 等。\n\nCPU 列：\n\n接下来的列表示各个 CPU 核心上该中断被触发的次数。在你的输出中，有 CPU0 和 CPU1，后面分别是它们上面的中断触发计数。\n\n中断类型：\n\n中断的类型（如 GICv3 和 MSI），表示该中断的来源和处理方式。\n\nGICv3：代表使用通用中断控制器（Generic Interrupt Controller）版本 3。\nMSI（Message Signaled Interrupts）：一种通过消息而不是物理线路发送中断的机制。\n\n中断编号/级别：\n\n某些中断行后面有数字（如 27, 32），这些数字通常表示该中断的向量号或中断级别。\nLevel 表示该中断为电平触发（持续有效）中断。\nEdge 表示为边缘触发中断（只在状态变化时有效）。\n\n设备名称：\n\n最后一列通常是中断源设备的描述，表示触发该中断的硬件设备。例如：\n\narch_timer：表示体系结构定时器。\npciehp：表示 PCI Express 热插拔控制器。\nens160-rx-0 和 ens160-tx-0：表示网络接口卡的接收和发送中断。\n\n2) 示例行解释\n\n10: 690796 792946 GICv3 27 Level arch_timer：\n\n中断号为 10。\nCPU0 上该中断触发了 690796 次，CPU1 上触发了 792946 次。\n中断类型为 GICv3，向量号为 27，为电平触发。\n设备为 arch_timer，表示这是体系结构定时器的中断。\n\n3) IPI（Inter-Processor Interrupts）\n\nIPI 代表处理器间中断（Inter-Processor Interrupts），用于在多核处理器系统中进行通信或协调。例子包括：\n\nIPI0 表示重新调度中断，触发次数分别为 9633 和 18455。",
		"tags": [ "note"]
},

{
		"title": "文件描述符",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/文件描述符/",
		"content": "文件描述符\n对于内核而言，所有打开的文件都通过文件描述符（file descriptor）引用。通常也写作 fd。\n文件描述符是一个非负整数。\n当打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n文件描述符是跟进程相关联的。\n按照惯例，UNIX 系统将 fd 0 对应进程的标准输入， fd 1 对应进程的标准输出， fd 2 对应进程的标准错误。\n系统调用中的文件描述符\nUNIX 系统中，一切皆文件，所以一切资源都可以使用文件描述符进程引用。\n以 open 系统调用为例\n使用 man 2 open 查看系统 man 手册\nNAME\nopen, openat -- open or create a file for reading or writing\n\nSYNOPSIS\n#include &lt;fcntl.h&gt;\n\nint\nopen(const char *path, int oflag, ...);\n\nint\nopenat(int fd, const char *path, int oflag, ...);\n\nDESCRIPTION\nThe file name specified by path is opened for reading and/or writing,\nas specified by the argument oflag; the file descriptor is returned to\nthe calling process.\n\n在简介中有一段话：the file descriptor is returned to the calling process.\n使用 c 语言打开一个 文件\n#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n\tint fd;\n\tfd = open(&quot;tmp.txt&quot;, O_RDONLY);\n\tprintf(&quot;%d&quot;, fd);\n\tsleep(10);\n}\n\n会发现，在进程运行时 fd 目录下，会出现一个描述符 3 指向了 打开的文件\n$ ll /proc/$(ps aux | grep a.out | grep -v grep | awk '{print $2}')/fd\ntotal 0\nlrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 0 -&gt; /dev/pts/4\nlrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 1 -&gt; /dev/pts/4\nlrwx------ 1 ubuntu ubuntu 64 Apr 13 13:48 2 -&gt; /dev/pts/4\nlr-x------ 1 ubuntu ubuntu 64 Apr 13 13:48 3 -&gt; /home/ubuntu/mydisk/yangblog/codes/file/tmp.txt\n\n我们可以把这个文件描述符当做参数传递给 read 或者 write 等等系统调用。",
		"tags": ["include", "include", "include", "include", "note","文件","操作系统","描述符","文件描述符"]
},

{
		"title": "滑动窗口模板",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/滑动窗口模板/",
		"content": "滑动窗口模板\n以 1052. 爱生气的书店老板 为例\nclass Solution {\n\n/**\n* @param Integer[] $customers\n* @param Integer[] $grumpy\n* @param Integer $X\n* @return Integer\n*/\nfunction maxSatisfied($customers, $grumpy, $X) {\nif (empty($customers)) {\nreturn 0;\n}\n\n// 1. 计算初始状态： 不压抑的时候，最大的满意人数\n$maxSat = 0;\nforeach ($grumpy as $key =&gt; $g) {\nif ($g == 0) {\n$maxSat += $customers[$key];\n}\n}\n\t\t\n\t\t// 1.1 初始化左右指针位置\n$len = count($customers);\n$left = $right = 0;\n$curSat = $maxSat;\n\t\t\n// 2. 滑窗具体代码\n// 2.1 右指针一直往右做\nwhile ($right &lt; $len) {\n$span = $right - $left + 1;\n\n// 2.1 直到遇到临界条件之后，左指针往右走，直到满足临界条件\nif ($span &gt; $X) {\nif ($grumpy[$left]) {\n$curSat -= $customers[$left];\n}\n$left ++;\n}\n\n// 计算当前窗口的数值\nif ($grumpy[$right]) {\n$curSat += $customers[$right];\n}\n\t\t\t\n// 最终结果比较\n$maxSat = max($curSat, $maxSat);\n$right++;\n}\n\nreturn $maxSat;\n}\n}\n\n多看几个题解：\n\nlc 的官方题解： 爱生气的书店老板\n一般官方题解的思路会非常详细，建议多看几遍\n用「秘密技巧」挽留住最多的原本因为生气而被赶走的顾客",
		"tags": [ "note","leetcode"]
},

{
		"title": "算法新年祝福语",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/算法新年祝福语/",
		"content": "算法新年祝福语\n祝你冒泡排序，选择排序，插入排序，快速排序，堆排序，归并排序，希尔排序，桶排序，基数排序新年帮您排忧解难。\n有向图，无向图，有环图，无环图，完全图，稠密图，稀疏图，拓扑图祝您新年宏图大展。\n最长路，最短路，单源路径，所有节点对路径祝您新年路路通畅。\n二叉树，红黑树，van Emde Boas树，最小生成树祝您新年好运枝繁叶茂。\n最大流，网络流，标准输入流，标准输出流，文件输入流，文件输出流祝您新年顺顺流流。\n线性动规，区间动规，坐标动规，背包动规，树型动归为您的新年规划精彩。\n散列表，哈希表，邻接表，双向链表，循环链表帮您在新年表达喜悦。",
		"tags": [ "note"]
},

{
		"title": "系统调用时上下文调度",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/系统调用时上下文调度/",
		"content": "系统调用时上下文调度\nCPU 的特权等级：\nlinux 中只使用了 Ring 0 和 Ring3\n\n在系统调用时可能会发生上下文切换，但这取决于具体情况。系统调用涉及从用户态（User Mode）切换到内核态（Kernel Mode），这是一个模式切换，不一定总是伴随完整的进程上下文切换。让我们更详细地看一下：\n1) 用户态和内核态切换（模式切换）\n当一个进程执行系统调用时，CPU 会从用户态切换到内核态，以便操作系统内核执行需要访问硬件资源或特权操作的指令（如文件读写、内存管理等）。这叫做模式切换。\n\n模式切换 ≠ 上下文切换：\n模式切换是 CPU 从执行用户代码切换到执行内核代码，并不涉及进程的完整上下文（如寄存器、页表、内存等）切换，因此它比完整的上下文切换开销要小。\n\n2) 系统调用时的上下文切换\n在以下几种情况下，系统调用会导致真正的进程上下文切换：\n\n进程阻塞：\n如果系统调用需要等待某些事件（如 I/O 操作、网络请求、锁等），当前进程会被挂起，进入等待状态。此时，操作系统会进行进程上下文切换，将 CPU 资源分配给其他进程执行，直到当前进程的请求完成，再切换回该进程继续执行。\n例如：\n\n调用 read() 时，如果数据还没有准备好，进程会进入阻塞状态，等待 I/O 完成，导致上下文切换。\n\n时间片用完：\n如果系统调用时间过长，进程在内核态执行时，可能会因为时间片耗尽被操作系统调度器切换出去，调度其他进程。这样会产生上下文切换。\n\n高优先级进程的出现：\n当进程在系统调用中运行时，如果有更高优先级的进程进入可运行队列，操作系统可能强制进行上下文切换，将 CPU 资源让给更高优先级的进程。\n\n3) 不会导致上下文切换的系统调用\n某些系统调用不会导致上下文切换，比如短时间内能立即完成的调用。典型的例子包括：\n\ngetpid()：返回进程的 PID，几乎是瞬时操作。\ngettimeofday()：获取当前时间，操作非常快。\n\n这些系统调用通常只涉及模式切换（从用户态切换到内核态再返回），不会导致进程切换。\n4) 总结\n系统调用时不一定会发生上下文切换：\n\n如果系统调用涉及 I/O 操作或进程需要等待某些资源时，系统会发生进程上下文切换。\n仅涉及用户态和内核态的模式切换时，不涉及完整的上下文切换，开销较小。\n\n5) 参考\n\n操作系统之哲学原理第2版 - 3.3 内核态和用户态 - 邹恒明 - 微信读书: https://weread.qq.com/web/reader/9eb326d05933d79ebf22eb3k6ea321b021d6ea9ab1ba605\n现代操作系统（原书第4版） (豆瓣): https://book.douban.com/subject/27096665/",
		"tags": [ "note"]
},

{
		"title": "线程上下文切换详情",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/线程上下文切换详情/",
		"content": "线程上下文切换详情\n线程上下文切换与进程上下文切换类似，但由于线程是轻量级的进程，线程上下文切换主要涉及保存和恢复线程的执行状态，而无需切换进程的虚拟内存空间和其他与进程相关的资源。以下是线程上下文切换时需要保存和恢复的主要内容：\n1 CPU 寄存器状态\n与进程上下文切换一样，线程上下文切换中，最重要的是保存和恢复 CPU 的寄存器状态，具体包括：\n\n程序计数器（Program Counter，PC）：保存当前线程正在执行的指令地址，以便恢复时从该地址继续执行。\n栈指针（Stack Pointer，SP）：保存当前线程的栈顶指针，指向当前调用栈的位置。\n通用寄存器：保存线程当前的寄存器状态，包括 CPU 寄存器中的数据、临时变量、函数参数等内容。\n状态寄存器（Flags）：保存 CPU 的状态标志，如是否有中断、溢出或进位等。\n\n这些寄存器状态会保存在 线程控制块（Thread Control Block，TCB） 中。\n2 线程栈\n每个线程都有独立的栈，用于存储函数调用的局部变量、返回地址等。在上下文切换时，操作系统会切换到新线程的栈指针，指向该线程的栈顶。\n3 程序状态字（Program Status Word，PSW）\n和进程一样，线程上下文切换时也需要保存程序状态字，记录线程的运行状态（如用户态或内核态）、中断状态等信息。\n4 线程本地存储（Thread-Local Storage，TLS）\n线程可能会使用线程本地存储来保存",
		"tags": [ "note"]
},

{
		"title": "网络-最多有多少个a类、b类和c类网络号",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/网络-最多有多少个a类、b类和c类网络号/",
		"content": "在IPv4地址体系中，网络被分为4个等级，分别是A，B，C和D类。对于A、B、C类，其数量如下：\n\nA类：128个（范围是0.0.0.0到127.255.255.255，但0.0.0.0和127.0.0.0通常分别用作默认路由和本地回环地址，所以不包括在内。）\nB类：16,384个（范围是 128.0.0.0 到 191.255.255.255）\nC类：2,097,152个（范围是 192.0.0.0 到 223.255.255.255）\n\n请注意，上述分类是根据原始的IPv4地址分类来计算的。然而，由于IP地址的枯竭，现在的实际网络环境中，通常在IP地址分配上使用了子网划分，CIDR，私有地址等现代网络技术，因此实际的可用网络数量会因子网划分、私有地址使用等因素而有所变化。\nD类 IP 地址是多播（Multicast）地址，其范围是 224.0.0.0 到 239.255.255.255。\n所以，D类网络（多播地址）总共有 (239-224+1) x (2^24) = 268,435,456 个。\n但是，有些特定的地址在D类中是已经被保留或特殊用途的，例如 224.0.0.0 - 224.0.0.255 是被保留的用于本地网络的多播地址。\n参考\nhttps://blog.csdn.net/a5534789/article/details/50118857#:~:text=“0”做为网络号,网段为1—126.&amp;text=224%3D412%3D166%3D2563,数应该是16777214个。",
		"tags": [ "note"]
},

{
		"title": "202405081320 IPv6的回环地址是如何表示的",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/网络/202405081320 IPv6的回环地址是如何表示的/",
		"content": "202405081320 IPv6的回环地址是如何表示的\n::1",
		"tags": [ "note","network"]
},

{
		"title": "202404191548 GTD的主要思想",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/节省时间/202404191548 GTD的主要思想/",
		"content": "202404191548 GTD的主要思想\n\n把事情做好\n执行时是拿结果engage（而不是仅仅去 exec）\n\n主要思想：\n\n捕获\n处理，明确下一步行动是什么\n\nbilibili教程\n\n重新认识GTD\n#Omnivore\nRead on Omnivore\nRead Original\nNotes",
		"tags": ["Omnivore", "note"]
},

{
		"title": "获取进程存活时间",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/获取进程存活时间/",
		"content": "ps -eo lstart,pid,cmd | grep &quot;php-fpm: pool www&quot; | grep -v 'grep'\n\n要在 Linux 中获取子进程的存活时间（以 Unix 时间戳的形式表示），可以使用以下步骤：\n\n获取子进程的 PID。\n访问 /proc/&lt;PID&gt;/stat 文件，其中 &lt;PID&gt; 是子进程的 PID。\n从 /proc/&lt;PID&gt;/stat 文件中读取进程的启动时间（start_time），该值以时钟滴答数（clock ticks）的形式存储在第 22 列中。\n获取系统的时钟滴答数，可以使用 getconf CLK_TCK 命令。\n将进程的启动时间除以时钟滴答数，以获取进程的存活时间（单位为秒），然后将其添加到系统启动时间的 Unix 时间戳（即系统启动的时间，以秒为单位）中，即可得到子进程的存活时间（以 Unix 时间戳的形式表示）。\n\n以下是获取子进程存活时间的 Unix 时间戳的示例命令：\n# 获取进程存活时间\nPID=&lt;子进程的 PID&gt;\n\n# 获取进程的启动时间（以时钟滴答数的形式存储）\nSTART_TIME=$(awk '{print $22}' /proc/${PID}/stat)\n\n# 获取系统的时钟滴答数\nCLK_TCK=$(getconf CLK_TCK)\n\n# 计算进程的存活时间（以秒为单位）\nUPTIME=$((($(awk '{print $1}' /proc/uptime) - ${START_TIME} / ${CLK_TCK})))\n\n# 计算子进程的存活时间（以 Unix 时间戳的形式表示）\nCHILD_UPTIME=$(( $(date +%s) - ${UPTIME} ))\n\necho &quot;子进程的存活时间为：${CHILD_UPTIME} 秒（Unix 时间戳形式）&quot;\n\n注意，这个方法获取的存活时间不是绝对准确的，因为在读取进程的启动时间和计算子进程的存活时间期间，进程的存活时间可能会发生变化。\n参考",
		"tags": [ "note","linux","shell"]
},

{
		"title": "计算机中断",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/计算机中断/",
		"content": "计算机中断\n1 什么是中断\n中断[1]（英语：Interrupt），又称插断，在计算机科学中是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应予以注意，这种情况就称为中断。\n2 中断是如何工作的\n计算机中的中断机制是CPU和操作系统共同配合的结果。\n\nCPU层面的机制：\n中断在硬件层面是由CPU管理的。CPU中内置了处理中断的硬件电路，当接收到中断信号时，它会暂停当前正在执行的指令，将程序计数器（PC）和相关寄存器的内容保存起来，然后跳转到一个预定义的中断处理程序的入口地址。CPU需要具备检测中断信号、保存现场（当前程序的状态）、并执行相应的中断处理程序的能力。\n\n操作系统层面的机制：\n中断处理程序（Interrupt Service Routine, ISR）通常是由操作系统编写和管理的。操作系统负责：\n\n注册和管理中断处理程序。\n响应不同的中断类型（如硬件中断、软件中断、时钟中断等）。\n保存和恢复进程的上下文，确保中断处理完毕后能够恢复正常程序执行。\n控制任务调度，在多任务环境下，当中断发生时，操作系统会决定是继续运行当前任务，还是切换到其他任务。\n\n因此，中断机制的基础来自于CPU硬件支持，而操作系统负责管理中断的高层逻辑。两者紧密协作，确保中断处理的高效和系统的正常运行。\n一般来说，中断的优先级高于普通进程\n3 中断的种类\n3.1 硬件中断\n硬件中断是由计算机外部硬件设备（如键盘、鼠标、硬盘、网络接口等）或内部硬件组件（如定时器、控制器）生成的信号，用来通知CPU发生了某个事件，要求CPU暂停当前任务并立即进行处理。这是一种异步的通信方式，能够确保外部设备与CPU高效互动。\n\n键盘中断：当你按下一个键时，键盘发送一个中断信号给CPU，CPU暂停当前任务，读取按键数据。\n鼠标中断：移动鼠标时，鼠标发送中断信号给CPU，CPU响应并处理移动事件。\n定时器中断：系统定时器会周期性地向CPU发送中断信号，用于管理任务调度和系统时钟。\n\n3.2 软件中断\n软件中断是由程序通过特定的指令主动触发的中断，它通常用于实现系统调用或处理特定的程序异常。与硬件中断不同，软件中断是由软件发出的，而不是由外部设备或硬件组件引发的。\n\n系统调用（System Call）： 软件中断最常见的用途是实现系统调用。当应用程序需要操作系统提供的服务（如文件读写、内存分配、网络通信等）时，它会触发一个软件中断。操作系统会捕获该中断并执行相应的服务，随后返回给应用程序。这种机制让用户程序能够安全、受控地访问操作系统的资源。\n异常处理（Exception Handling）： 当程序运行时发生某些异常（如除零错误、非法内存访问），CPU会自动触发软件中断，进入异常处理程序进行处理。\n调试（Debugging）： 软件中断也可以用于调试。例如，调试器通过在代码中插入断点，利用软件中断暂停程序的执行，检查当前状态，从而帮助开发者进行故障排查。\n\n3.3 Linux 中断处理\nLinux 将中断处理过程分成了两个阶段，也就是上半部和下半部：\n\n上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。 对应硬中断，快速执行\n下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。 对应软中断，延迟执行\n\n3.3.1 查看中断\n\n/proc/softirqs 提供了软中断的运行情况；\n\nCPU0 CPU1\nHI: 32 4\nTIMER: 217168 160788\nNET_TX: 58113 1\nNET_RX: 73923 35\nBLOCK: 12544 10\nIRQ_POLL: 0 0\nTASKLET: 2802 54\nSCHED: 283839 258237\nHRTIMER: 0 0\nRCU: 116166 128092\n\n具体字段解释如下：\n\nHI：高优先级软中断，用于处理非常紧急的软中断任务，极少使用。\nTIMER：定时器软中断，系统定时器触发的中断。用于定期任务（如进程调度、系统计时）的处理。\nNET_TX：网络传输（发送）软中断，处理网络数据包的发送。\nNET_RX：网络接收软中断，处理网络数据包的接收。\nBLOCK：块设备 I/O 的软中断，处理硬盘等块设备的 I/O 操作。\nBLOCK_IOPOLL：块设备 I/O 轮询软中断，处理块设备的 I/O 轮询操作，通常在高性能场景中用到。\nTASKLET：任务队列（Tasklets），用于延迟执行一些非紧急任务。\nSCHED：调度软中断，触发进程调度相关的任务。\nHRTIMER：高精度定时器软中断，用于高精度计时任务。\nRCU：RCU（Read-Copy Update）软中断，RCU 是 Linux 内核中的一种同步机制，通常用于读写锁的管理和延迟删除任务。\n\n软中断实际上是以内核线程的方式运行的，每个 CPU 都对应一个软中断内核线程，这个软中断内核线程就叫做 ksoftirqd/CPU 编号。\nwudanyang@dy-turbo-vm:~$ ps aux | grep softirq\nroot 16 0.0 0.0 0 0 ? S 02:08 0:00 [ksoftirqd/0]\nroot 24 0.0 0.0 0 0 ? S 02:08 0:00 [ksoftirqd/1]\n\n/proc/interrupts 提供了硬中断的运行情况。 <a class=\"internal-link\" target=\"\" data-note-icon=\"2\" href=\"/card/操作系统/CPU性能优化/硬件中断输出示例/\">硬件中断输出示例</a>\n\n4 参考\n\n中断 - 维基百科，自由的百科全书: https://zh.wikipedia.org/wiki/中斷 ↩︎",
		"tags": [ "note"]
},

{
		"title": "202404181227 补码",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/计算机组成原理/202404181227 补码/",
		"content": "202404181227 补码\n在计算机中，补码是一种表达有符号整数的方式，特别是在二进制数中。补码不仅可以表示正数，还可以表示负数，这使得负数的运算变得更为简单。\n补码的生成方法如下：\n如果是正数，补码与原码相同；\n如果是负数，补码是其原码中所有位取反（得到反码）后加1。\n例如，如果我们要表示-5，先找到+5的二进制表示，即&quot;0101&quot;（在4位二进制数中），然后取反得到&quot;1010&quot;，接着加1得到&quot;1011&quot;。所以，-5的补码为&quot;1011&quot;。\n补码的主要优点是可以简化计算机中的加减运算。因为在使用补码的情况下，计算机可以用同样的硬件来处理加法和减法。\n什么是补码",
		"tags": [ "note"]
},

{
		"title": "软装-沙发",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/软装-沙发/",
		"content": "软装 - 沙发\n材质\n\n布艺\n科技布？\n\n填充物\n\n一体成型\n海绵密度高于 50\n海绵加羽绒\n\n尺寸\n\n坐深 65cm 以上\n坐高 40cm 左右\n靠背高度 55cm 以上\n长度 3.2-3.5 米\n\n框架\n\n蛇形弹簧\n实木框架\n\n封底\n\n布艺封底\n\n颜色\n\n深色（不容易翻车）\n\nReference",
		"tags": [ "note","家"]
},

{
		"title": "进程上下文切换详情",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/进程上下文切换详情/",
		"content": "进程上下文切换详情\n当操作系统进行进程上下文切换时，CPU 会保存当前进程的状态并加载下一个要运行的进程的状态。具体来说，以下信息需要在进程上下文切换时保存和恢复：\n1 CPU 寄存器状态\n这是上下文切换中最关键的部分，因为寄存器中保存了当前进程的执行状态。具体包括：\n\n程序计数器（Program Counter，PC）：保存当前进程正在执行的指令地址，以便在恢复时从该地址继续执行。\n栈指针（Stack Pointer，SP）：指向当前进程的栈顶，保存当前进程的调用栈状态。\n通用寄存器：如 eax, ebx, ecx, edx 等 CPU 寄存器，存储进程的临时数据、函数参数和返回值等。\n状态寄存器（Flags）：保存当前 CPU 的状态标志位，如是否有进位、溢出或中断等。\n\n这些寄存器状态会保存在进程的**进程控制块（Process Control Block，PCB）**中。\n2 内存管理信息\n每个进程都有独立的虚拟内存空间，系统需要切换进程的内存映射，确保每个进程只能访问自己的内存。具体包括：\n\n页表（Page Table）：虚拟内存到物理内存的映射表，操作系统在上下文切换时需要更新页表，指向新进程的地址空间。\n段寄存器（Segment Registers）：如果使用段式内存管理，也需要切换段寄存器，指向新进程的代码段、数据段和栈段。\n\n3 程序状态字（Process Status Word，PSW）\n程序状态字记录了当前进程的运行模式（如用户态或内核态）、中断使能状态、优先级等。在上下文切换时，系统会保存当前进程的状态字，并恢复下一个进程的状态字。\n4 内核栈\n每个进程在内核态运行时都会有一个专属的内核栈，用来存储系统调用或中断处理过程中的数据。上下文切换时，操作系统会切换到下一个进程的内核栈。\n5 硬件上下文\n除了 CPU 寄存器，某些硬件设备（如浮点运算单元、SIMD 寄存器等）也可能需要保存状态。对于使用了这些硬件的进程，操作系统在切换时也需要保存这些硬件的状态，以便后续恢复。\n6 进程优先级和调度信息\n在上下文切换过程中，调度器会根据进程的优先级、剩余时间片等调度策略选择下一个要运行的进程。调度信息存储在 PCB 中。\n7 文件描述符表、信号处理状态等（较少切换）\n虽然这些信息在一般的上下文切换中不会频繁变动，但操作系统仍然为每个进程维护了与之相关的资源信息，包括：\n\n文件描述符表：记录进程打开的文件及其位置等信息。\n信号处理状态：记录进程当前的信号处理函数和挂起信号。\n\n8 进程上下文切换的总结步骤：\n\n保存当前进程状态：\n\n将当前进程的寄存器状态（程序计数器、栈指针、通用寄存器等）保存到 PCB 中。\n保存当前进程的内存管理信息（页表等）。\n\n切换内存空间：\n\n更新 CPU 的页表寄存器，使其指向新进程的地址空间。\n\n加载新进程状态：\n\n从新进程的 PCB 中恢复其寄存器状态、程序计数器等。\n切换到新进程的内核栈。\n\n恢复执行：\n\n将控制权交给新进程，从其上次暂停的位置继续执行。\n\n通过这些操作，CPU 可以在多个进程之间高效切换，使得操作系统能够实现多任务并发执行。",
		"tags": [ "note"]
},

{
		"title": "如何合并marginnote笔记本",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/阅读/如何合并marginnote笔记本/",
		"content": "如何合并marginnote笔记本\n一个文档的多个笔记本中的笔记能否合并？ - 方法、技巧、工作流 - MarginNote 中文社区",
		"tags": [ "note"]
},

{
		"title": "202405061046 音乐-圆桌骑士",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/card/音乐/202405061046 音乐-圆桌骑士/",
		"content": "202405061046 音乐-圆桌骑士\nhttps://music.163.com/song?id=2127857336&amp;userid=16553655\n很有西方的骑士感觉",
		"tags": [ "note"]
},

{
		"title": "20240415141933 什么是哲学",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/thoughts/20240415141933 什么是哲学/",
		"content": "20240415141933 什么是哲学\n哲学是在探究根本性的问题，【为什么】这个问题要问到根本\n比如，为什么要吃饭，因为要活着，为什么活着。。。",
		"tags": [ "note","哲学"]
},

{
		"title": "做事心得",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/thoughts/做事心得/",
		"content": "做事心得\n\n看书只要开始就能看得进去\n不要急着清空代办，如果出了问题，即使代办清空了也没有任何功劳\n周五不上线、不切流\n相信明天更美好，但是要过好当下\n自己的智商又不是很好，毅力也不是很高，算法学习也只能是慢慢学了，也就是为了不让自己的脑子生锈吧\n坚持骑车锻炼 2024年03月08日16:55:41\n最好维护的代码是没有写出来的代码 2024年03月12日13:44:30\n要因为做了什么而赞美，而不是是什么而赞美 2024年04月15日14:12:01",
		"tags": [ "note"]
},

{
		"title": "如何做监控",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/thoughts/如何做监控/",
		"content": "如何做监控\n监控：\n\n什么是监控？\n\n对线上质量的一个实时检查\n\n重要性\n\n发现线上问题（早于用户）\n快速止损、定位\n及时发现隐藏的问题，指导策略优化\n\n如何做好监控？\n\n监控的流程及内容\n\n监控需求提出\n监控需求开发\n监控需求测试\n监控指标确认\n监控报警添加\n\n确认监控内容\n\n新功能添加监控\n补充监控\n围绕\n\n系统正确性\n系统异常\n异常定位\n隐藏问题指导策略\n\n监控数据获取\n\n打点数据\n日志数据\n数据库数据\nredis 数据\n\n监控报警添加\n\n监控可视化\n确定触发报警策略\n确定报警频率\n确定报警接收人\n配置监控\n\n监控处理\n\n收到报警\n问题跟进\n问题周知\n问题处理\n定损\n复盘 &amp; casestudy\n\n监控报警优化\n\n漏报\n\n不同报警类型\n突升突降代替固定阈值\n\n无效报警太多（准确率）\n\n准确性提升\n\n放大时间窗口，屏蔽预期内的单点抖动\n工作日、节假日不同阈值\n\n推送方式优化\n\n连续失败\n通知间隔\n通知依赖\n不同方式报警（短信、电话）\n\n报警处理不及时\n\n自愈脚本等\n\n问题定位\n\n流量分析\n\n流量细分\n\n行业\n地域\n机房\n\n系统分析\n\n线上出现报错、fatal、pvlost\n例行上线功能影响\n数据变更\n\n监控发现有问题之后可以了解一下 <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">如何追查线上问题</a>",
		"tags": [ "note"]
},

{
		"title": "如何追查线上问题",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/thoughts/如何追查线上问题/",
		"content": "如何追查线上问题\n止损优先\n不能先追查问题根源， 首先应该止损，不让问题进一步扩大，代码回滚、服务降级等都可以起到止损的效果。\n对于止损有一个比较好的实践，新业务或者重构业务上线时，可以加一个 配置开关 控制是否启用逻辑，在发现有损时，可以及时关掉业务逻辑，比重新上线要快特别多\n及时通告\n在问题发生之后，要及时对处理问题的过程进行通告。特别是应对线上有损的问题时，更应该及时通告。在内部群中，简单描述一下问题与可能的原因，处理的进度。而在外部群里，可以只说一下处理的进度。如果有必要，可以将问题上诉到领导，如果还解决不了问题，可以逐级继续上诉。\n追查问题的方法\n逻辑方法:\n\n先收集现象：业务报错、线上报错日志等\n对紧急的问题来说，需要对线上业务、服务器等非常熟悉，才能迅速收集到有用的报错信息。\n针对现象假设原因：\n\n常见问题依据追查手册\n其他问题保持思路开放，大胆假设\n\n是否有损的判断：\n根据现象假设出可能的原因，判断是否是有损的，如果是有损的问题，参考 止损优先\n质疑所有数据：\n各个数据、监控系统等的有效性也需要质疑，不能完全相信，需要小心求证\n\n知识准备\n\n对线上各种日志的熟悉，从日志中能看到具体的问题，比如 nginx 日志 php 日志等\n对线上的各种配置更要做到心中有数\n对细节的追查，每次都更细一些，这样才能获得更多的信息\n计算机基本功，有时问题追查不下去，不是没有线索，而是追查到了一个未知的领域，没有相关的知识，无法追查\n\n总结经验\n\n成熟的方法落地成工具\n对问题的追查形成文档\n\n问题解决之后\n如果问题解决之后，我们就不再跟进了，那么我们就沦为了解决问题的工具，问题也随之越来越多，解决不完。\n那么，我们可以通过思考以下几点来提升自己\n\n线上是否恢复了正常？（最基本的）\n问题的原因是什么？（落到追查文档）\n通过什么手段恢复的？（解决方案）\n怎么可以避免下次再次出现问题？（防患未然）\n除了此次出现的问题，会不会有其他的问题出现（举一反三）\n出现此类问题是否是架构问题造成的？（根本原因）",
		"tags": [ "note","开发经验"]
},

{
		"title": "当前状态和下一状态的随想.excalidraw",
		"date":"Sat Oct 12 2024 14:42:21 GMT+0000 (Coordinated Universal Time)",
		"url":"/thoughts/当前状态和下一状态的随想.excalidraw/",
		"content": ".container {font-family: sans-serif; text-align: center;} .button-wrapper button {z-index: 1;height: 40px; width: 100px; margin: 10px;padding: 5px;} .excalidraw .App-menu_top .buttonList { display: flex;} .excalidraw-wrapper { height: 800px; margin: 50px; position: relative;} :root[dir=\"ltr\"] .excalidraw .layer-ui__wrapper .zen-mode-transition.App-menu_bottom--transition-left {transform: none;} (function(){const InitialData={\"type\":\"excalidraw\",\"version\":2,\"source\":\"https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/2.3.0\",\"elements\":[{\"type\":\"rectangle\",\"version\":124,\"versionNonce\":1939526015,\"index\":\"a0\",\"isDeleted\":false,\"id\":\"XgjAPiQ47fqEwl-LpfWxA\",\"fillStyle\":\"hachure\",\"strokeWidth\":1,\"strokeStyle\":\"solid\",\"roughness\":1,\"opacity\":100,\"angle\":0,\"x\":-120.83203125,\"y\":-187.431640625,\"strokeColor\":\"#000000\",\"backgroundColor\":\"transparent\",\"width\":153,\"height\":97,\"seed\":1809355819,\"groupIds\":[],\"frameId\":null,\"roundness\":{\"type\":3},\"boundElements\":[{\"type\":\"text\",\"id\":\"lcXa25o6\"},{\"id\":\"90yz_m0kH4RaMUXRgR-Br\",\"type\":\"arrow\"}],\"updated\":1724947112689,\"link\":null,\"locked\":false},{\"type\":\"text\",\"version\":107,\"versionNonce\":1163151857,\"index\":\"a1\",\"isDeleted\":false,\"id\":\"lcXa25o6\",\"fillStyle\":\"hachure\",\"strokeWidth\":1,\"strokeStyle\":\"solid\",\"roughness\":1,\"opacity\":100,\"angle\":0,\"x\":-84.33203125,\"y\":-163.931640625,\"strokeColor\":\"#000000\",\"backgroundColor\":\"transparent\",\"width\":80,\"height\":50,\"seed\":1671257323,\"groupIds\":[],\"frameId\":null,\"roundness\":null,\"boundElements\":[],\"updated\":1724947112689,\"link\":null,\"locked\":false,\"fontSize\":20,\"fontFamily\":1,\"text\":\"\\n当前状态\",\"rawText\":\"\\n当前状态\",\"textAlign\":\"center\",\"verticalAlign\":\"middle\",\"containerId\":\"XgjAPiQ47fqEwl-LpfWxA\",\"originalText\":\"\\n当前状态\",\"autoResize\":true,\"lineHeight\":1.25},{\"type\":\"rectangle\",\"version\":126,\"versionNonce\":543312287,\"index\":\"a2\",\"isDeleted\":false,\"id\":\"GZ7hQS78e5Q1siEvK33Lx\",\"fillStyle\":\"hachure\",\"strokeWidth\":1,\"strokeStyle\":\"solid\",\"roughness\":1,\"opacity\":100,\"angle\":0,\"x\":375.140625,\"y\":-190.029296875,\"strokeColor\":\"#000000\",\"backgroundColor\":\"transparent\",\"width\":153,\"height\":97,\"seed\":1586660869,\"groupIds\":[],\"frameId\":null,\"roundness\":{\"type\":3},\"boundElements\":[{\"id\":\"90yz_m0kH4RaMUXRgR-Br\",\"type\":\"arrow\"},{\"type\":\"text\",\"id\":\"Ymxj0WWT\"}],\"updated\":1724947112689,\"link\":null,\"locked\":false},{\"type\":\"text\",\"version\":117,\"versionNonce\":1157096401,\"index\":\"a3\",\"isDeleted\":false,\"id\":\"Ymxj0WWT\",\"fillStyle\":\"hachure\",\"strokeWidth\":1,\"strokeStyle\":\"solid\",\"roughness\":1,\"opacity\":100,\"angle\":0,\"x\":411.640625,\"y\":-154.029296875,\"strokeColor\":\"#000000\",\"backgroundColor\":\"transparent\",\"width\":80,\"height\":25,\"seed\":1849985227,\"groupIds\":[],\"frameId\":null,\"roundness\":null,\"boundElements\":[],\"updated\":1724947112689,\"link\":null,\"locked\":false,\"fontSize\":20,\"fontFamily\":1,\"text\":\"下一状态\",\"rawText\":\"下一状态\",\"textAlign\":\"center\",\"verticalAlign\":\"middle\",\"containerId\":\"GZ7hQS78e5Q1siEvK33Lx\",\"originalText\":\"下一状态\",\"autoResize\":true,\"lineHeight\":1.25},{\"type\":\"arrow\",\"version\":407,\"versionNonce\":177013279,\"index\":\"a4\",\"isDeleted\":false,\"id\":\"90yz_m0kH4RaMUXRgR-Br\",\"fillStyle\":\"hachure\",\"strokeWidth\":1,\"strokeStyle\":\"solid\",\"roughness\":1,\"opacity\":100,\"angle\":0,\"x\":38.5078125,\"y\":-134.16474201184522,\"strokeColor\":\"#000000\",\"backgroundColor\":\"transparent\",\"width\":325.34375000000006,\"height\":3.6042259213982675,\"seed\":343810891,\"groupIds\":[],\"frameId\":null,\"roundness\":{\"type\":2},\"boundElements\":[],\"updated\":1724947112992,\"link\":null,\"locked\":false,\"startBinding\":{\"elementId\":\"XgjAPiQ47fqEwl-LpfWxA\",\"gap\":6.33984375,\"focus\":0.11513603277860894,\"fixedPoint\":null},\"endBinding\":{\"elementId\":\"GZ7hQS78e5Q1siEvK33Lx\",\"gap\":11.2890625,\"focus\":-0.056492919794349276,\"fixedPoint\":null},\"lastCommittedPoint\":null,\"startArrowhead\":null,\"endArrowhead\":\"arrow\",\"points\":[[0,0],[325.34375000000006,-3.6042259213982675]]},{\"type\":\"text\",\"version\":169,\"versionNonce\":617431473,\"index\":\"a5\",\"isDeleted\":false,\"id\":\"LIFeX9WH\",\"fillStyle\":\"hachure\",\"strokeWidth\":1,\"strokeStyle\":\"solid\",\"roughness\":1,\"opacity\":100,\"angle\":0,\"x\":95.265625,\"y\":-171.51171875,\"strokeColor\":\"#000000\",\"backgroundColor\":\"transparent\",\"width\":182,\"height\":25,\"seed\":591423115,\"groupIds\":[],\"frameId\":null,\"roundness\":null,\"boundElements\":[],\"updated\":1724947112689,\"link\":null,\"locked\":false,\"fontSize\":20,\"fontFamily\":1,\"text\":\"中间可能过了亿万年\",\"rawText\":\"中间可能过了亿万年\",\"textAlign\":\"left\",\"verticalAlign\":\"top\",\"containerId\":null,\"originalText\":\"中间可能过了亿万年\",\"autoResize\":true,\"lineHeight\":1.25}],\"appState\":{\"theme\":\"light\",\"viewBackgroundColor\":\"#ffffff\",\"currentItemStrokeColor\":\"#000000\",\"currentItemBackgroundColor\":\"transparent\",\"currentItemFillStyle\":\"hachure\",\"currentItemStrokeWidth\":1,\"currentItemStrokeStyle\":\"solid\",\"currentItemRoughness\":1,\"currentItemOpacity\":100,\"currentItemFontFamily\":1,\"currentItemFontSize\":20,\"currentItemTextAlign\":\"left\",\"currentItemStartArrowhead\":null,\"currentItemEndArrowhead\":\"arrow\",\"scrollX\":249.5113525390625,\"scrollY\":552.8409118652344,\"zoom\":{\"value\":1},\"currentItemRoundness\":\"round\",\"gridSize\":null,\"gridColor\":{\"Bold\":\"#C9C9C9\",\"Regular\":\"#EDEDED\"},\"colorPalette\":{},\"currentStrokeOptions\":null,\"previousGridSize\":null,\"frameRendering\":{\"enabled\":true,\"clip\":true,\"name\":true,\"outline\":true},\"objectsSnapModeEnabled\":false},\"files\":{}};InitialData.scrollToContent=true;App=()=>{const e=React.useRef(null),t=React.useRef(null),[n,i]=React.useState({width:void 0,height:void 0});return React.useEffect(()=>{i({width:t.current.getBoundingClientRect().width,height:t.current.getBoundingClientRect().height});const e=()=>{i({width:t.current.getBoundingClientRect().width,height:t.current.getBoundingClientRect().height})};return window.addEventListener(\"resize\",e),()=>window.removeEventListener(\"resize\",e)},[t]),React.createElement(React.Fragment,null,React.createElement(\"div\",{className:\"excalidraw-wrapper\",ref:t},React.createElement(ExcalidrawLib.Excalidraw,{ref:e,width:n.width,height:n.height,initialData:InitialData,viewModeEnabled:!0,zenModeEnabled:!0,gridModeEnabled:!1})))},excalidrawWrapper=document.getElementById(\"当前状态和下一状态的随想excalidraw.md\");ReactDOM.render(React.createElement(App),excalidrawWrapper);})();",
		"tags": [ "note","excalidraw"]
}
]